"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next";
exports.ids = ["vendor-chunks/i18next"];
exports.modules = {

/***/ "(ssr)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst isString = (obj)=>typeof obj === \"string\";\nconst defer = ()=>{\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n};\nconst makeString = (object)=>{\n    if (object == null) return \"\";\n    return \"\" + object;\n};\nconst copy = (a, s, t)=>{\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = (key)=>key && key.indexOf(\"###\") > -1 ? key.replace(lastOfPathSeparatorRegExp, \".\") : key;\nconst canNotTraverseDeeper = (object)=>!object || isString(object);\nconst getLastOfPath = (object, path, Empty)=>{\n    const stack = !isString(path) ? path : path.split(\".\");\n    let stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper(object)) return {};\n        const key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper(object)) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n};\nconst setPath = (object, path, newValue)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    let e = path[path.length - 1];\n    let p = path.slice(0, path.length - 1);\n    let last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = `${p[p.length - 1]}.${e}`;\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== \"undefined\") {\n            last.obj = undefined;\n        }\n    }\n    last.obj[`${last.k}.${e}`] = newValue;\n};\nconst pushPath = (object, path, newValue, concat)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n};\nconst getPath = (object, path)=>{\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;\n    return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key)=>{\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite)=>{\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\nconst regexEscape = (str)=>str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nconst escape = (data)=>{\n    if (isString(data)) {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n};\nclass RegExpCache {\n    constructor(capacity){\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n    getRegExp(pattern) {\n        const regExpFromCache = this.regExpMap.get(pattern);\n        if (regExpFromCache !== undefined) {\n            return regExpFromCache;\n        }\n        const regExpNew = new RegExp(pattern);\n        if (this.regExpQueue.length === this.capacity) {\n            this.regExpMap.delete(this.regExpQueue.shift());\n        }\n        this.regExpMap.set(pattern, regExpNew);\n        this.regExpQueue.push(pattern);\n        return regExpNew;\n    }\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator)=>{\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n};\nconst deepFind = (obj, path, keySeparator = \".\")=>{\n    if (!obj) return undefined;\n    if (obj[path]) {\n        if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;\n        return obj[path];\n    }\n    const tokens = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < tokens.length;){\n        if (!current || typeof current !== \"object\") {\n            return undefined;\n        }\n        let next;\n        let nextPath = \"\";\n        for(let j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    \"string\",\n                    \"number\",\n                    \"boolean\"\n                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n};\nconst getCleanedCode = (code)=>code?.replace(\"_\", \"-\");\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        console?.[type]?.apply?.(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger, options1 = {}){\n        this.init(concreteLogger, options1);\n    }\n    init(concreteLogger, options1 = {}) {\n        this.prefix = options1.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options1;\n        this.debug = options1.debug;\n    }\n    log(...args) {\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn(...args) {\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error(...args) {\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate(...args) {\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options1) {\n        options1 = options1 || this.options;\n        options1.prefix = options1.prefix || this.prefix;\n        return new Logger(this.logger, options1);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            if (!this.observers[event]) this.observers[event] = new Map();\n            const numListeners = this.observers[event].get(listener) || 0;\n            this.observers[event].set(listener, numListeners + 1);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event].delete(listener);\n    }\n    emit(event, ...args) {\n        if (this.observers[event]) {\n            const cloned = Array.from(this.observers[event].entries());\n            cloned.forEach(([observer, numTimesAdded])=>{\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer(...args);\n                }\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = Array.from(this.observers[\"*\"].entries());\n            cloned.forEach(([observer, numTimesAdded])=>{\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                }\n            });\n        }\n    }\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data, options1 = {\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: \"translation\"\n    }){\n        super();\n        this.data = data || {};\n        this.options = options1;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key, options1 = {}) {\n        const keySeparator = options1.keySeparator !== undefined ? options1.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options1.ignoreJSONStructure !== undefined ? options1.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path;\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        } else {\n            path = [\n                lng,\n                ns\n            ];\n            if (key) {\n                if (Array.isArray(key)) {\n                    path.push(...key);\n                } else if (isString(key) && keySeparator) {\n                    path.push(...key.split(keySeparator));\n                } else {\n                    path.push(key);\n                }\n            }\n        }\n        const result = getPath(this.data, path);\n        if (!result && !ns && !key && lng.indexOf(\".\") > -1) {\n            lng = path[0];\n            ns = path[1];\n            key = path.slice(2).join(\".\");\n        }\n        if (result || !ignoreJSONStructure || !isString(key)) return result;\n        return deepFind(this.data?.[lng]?.[ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value, options1 = {\n        silent: false\n    }) {\n        const keySeparator = options1.keySeparator !== undefined ? options1.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options1.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources, options1 = {\n        silent: false\n    }) {\n        for(const m in resources){\n            if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options1.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite, options1 = {\n        silent: false,\n        skipCopy: false\n    }) {\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (!options1.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options1.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options1, translator) {\n        processors.forEach((processor)=>{\n            value = this.processors[processor]?.process(value, key, options1, translator) ?? value;\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nconst shouldHandleAsObject = (res)=>!isString(res) && typeof res !== \"boolean\" && typeof res !== \"number\";\nclass Translator extends EventEmitter {\n    constructor(services, options1 = {}){\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options1;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key, o = {\n        interpolation: {}\n    }) {\n        const opt = {\n            ...o\n        };\n        if (key == null) return false;\n        const resolved = this.resolve(key, opt);\n        return resolved?.res !== undefined;\n    }\n    extractFromKey(key, opt) {\n        let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n        let namespaces = opt.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces: isString(namespaces) ? [\n                        namespaces\n                    ] : namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        return {\n            key,\n            namespaces: isString(namespaces) ? [\n                namespaces\n            ] : namespaces\n        };\n    }\n    translate(keys, o, lastKey) {\n        let opt = typeof o === \"object\" ? {\n            ...o\n        } : o;\n        if (typeof opt !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            opt = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") opt = {\n            ...opt\n        };\n        if (!opt) opt = {};\n        if (keys == null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;\n        const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], opt);\n        const namespace = namespaces[namespaces.length - 1];\n        let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const lng = opt.lng || this.language;\n        const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng?.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(opt)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(opt)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, opt);\n        let res = resolved?.res;\n        const resUsedKey = resolved?.usedKey || key;\n        const resExactUsedKey = resolved?.exactUsedKey || key;\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n        const hasDefaultValue = Translator.hasDefaultValue(opt);\n        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : \"\";\n        const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {\n            ordinal: false\n        }) : \"\";\n        const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n        const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;\n        let resForObjHndl = res;\n        if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {\n            resForObjHndl = defaultValue;\n        }\n        const handleAsObject = shouldHandleAsObject(resForObjHndl);\n        const resType = Object.prototype.toString.apply(resForObjHndl);\n        if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {\n            if (!opt.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {\n                    ...opt,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(opt);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = Array.isArray(resForObjHndl);\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in resForObjHndl){\n                    if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        if (hasDefaultValue && !res) {\n                            copy[m] = this.translate(deepKey, {\n                                ...opt,\n                                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                        } else {\n                            copy[m] = this.translate(deepKey, {\n                                ...opt,\n                                ...{\n                                    joinArrays: false,\n                                    ns: namespaces\n                                }\n                            });\n                        }\n                        if (copy[m] === deepKey) copy[m] = resForObjHndl[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, opt, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...opt,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);\n                } else {\n                    lngs.push(opt.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);\n                    } else if (this.backendConnector?.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            const suffixes = this.pluralResolver.getSuffixes(language, opt);\n                            if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                                suffixes.push(`${this.options.pluralSeparator}zero`);\n                            }\n                            suffixes.forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, opt, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {\n                res = `${namespace}${nsSeparator}${key}`;\n            }\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : undefined, opt);\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(opt);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, opt, resolved, lastKey) {\n        if (this.i18nFormat?.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...opt\n            }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!opt.skipInterpolation) {\n            if (opt.interpolation) this.interpolator.init({\n                ...opt,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...opt.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) opt.nest = false;\n            }\n            if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;\n            if (opt.nest !== false) res = this.interpolator.nest(res, (...args)=>{\n                if (lastKey?.[0] === args[0] && !opt.context) {\n                    this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return this.translate(...args, key);\n            }, opt);\n            if (opt.interpolation) this.interpolator.reset();\n        }\n        const postProcess = opt.postProcess || this.options.postProcess;\n        const postProcessorNames = isString(postProcess) ? [\n            postProcess\n        ] : postProcess;\n        if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(opt)\n                },\n                ...opt\n            } : opt, this);\n        }\n        return res;\n    }\n    resolve(keys, opt = {}) {\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (isString(keys)) keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, opt);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = opt.count !== undefined && !isString(opt.count);\n            const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;\n            const needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === \"number\") && opt.context !== \"\";\n            const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat?.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${opt.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, opt);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key, options1 = {}) {\n        if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options1);\n        return this.resourceStore.getResource(code, ns, key, options1);\n    }\n    getUsedParamsDetails(options1 = {}) {\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options1.replace && !isString(options1.replace);\n        let data = useOptionsReplaceForData ? options1.replace : options1;\n        if (useOptionsReplaceForData && typeof options1.count !== \"undefined\") {\n            data.count = options1.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options1) {\n        const prefix = \"defaultValue\";\n        for(const option in options1){\n            if (Object.prototype.hasOwnProperty.call(options1, option) && prefix === option.substring(0, prefix.length) && undefined !== options1[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nclass LanguageUtil {\n    constructor(options1){\n        this.options = options1;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (isString(code) && code.indexOf(\"-\") > -1) {\n            let formattedCode;\n            try {\n                formattedCode = Intl.getCanonicalLocales(code)[0];\n            } catch (e) {}\n            if (formattedCode && this.options.lowerCaseLng) {\n                formattedCode = formattedCode.toLowerCase();\n            }\n            if (formattedCode) return formattedCode;\n            if (this.options.lowerCaseLng) {\n                return code.toLowerCase();\n            }\n            return code;\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngScOnly = this.getScriptPartFromCode(code);\n                if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(\"-\") > 0 && lngOnly.indexOf(\"-\") < 0 && supportedLng.substring(0, supportedLng.indexOf(\"-\")) === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (isString(fallbacks)) fallbacks = [\n            fallbacks\n        ];\n        if (Array.isArray(fallbacks)) return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (isString(code) && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (isString(code)) {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nconst dummyRule = {\n    select: (count)=>count === 1 ? \"one\" : \"other\",\n    resolvedOptions: ()=>({\n            pluralCategories: [\n                \"one\",\n                \"other\"\n            ]\n        })\n};\nclass PluralResolver {\n    constructor(languageUtils, options1 = {}){\n        this.languageUtils = languageUtils;\n        this.options = options1;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        this.pluralRulesCache = {};\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    clearCache() {\n        this.pluralRulesCache = {};\n    }\n    getRule(code, options1 = {}) {\n        const cleanedCode = getCleanedCode(code === \"dev\" ? \"en\" : code);\n        const type = options1.ordinal ? \"ordinal\" : \"cardinal\";\n        const cacheKey = JSON.stringify({\n            cleanedCode,\n            type\n        });\n        if (cacheKey in this.pluralRulesCache) {\n            return this.pluralRulesCache[cacheKey];\n        }\n        let rule;\n        try {\n            rule = new Intl.PluralRules(cleanedCode, {\n                type\n            });\n        } catch (err) {\n            if (!Intl) {\n                this.logger.error(\"No Intl support, please use an Intl polyfill!\");\n                return dummyRule;\n            }\n            if (!code.match(/-|_/)) return dummyRule;\n            const lngPart = this.languageUtils.getLanguagePartFromCode(code);\n            rule = this.getRule(lngPart, options1);\n        }\n        this.pluralRulesCache[cacheKey] = rule;\n        return rule;\n    }\n    needsPlural(code, options1 = {}) {\n        let rule = this.getRule(code, options1);\n        if (!rule) rule = this.getRule(\"dev\", options1);\n        return rule?.resolvedOptions().pluralCategories.length > 1;\n    }\n    getPluralFormsOfKey(code, key, options1 = {}) {\n        return this.getSuffixes(code, options1).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code, options1 = {}) {\n        let rule = this.getRule(code, options1);\n        if (!rule) rule = this.getRule(\"dev\", options1);\n        if (!rule) return [];\n        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options1.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n    }\n    getSuffix(code, count, options1 = {}) {\n        const rule = this.getRule(code, options1);\n        if (rule) {\n            return `${this.options.prepend}${options1.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return this.getSuffix(\"dev\", count, options1);\n    }\n}\nconst deepFindWithDefaults = (data, defaultData, key, keySeparator = \".\", ignoreJSONStructure = true)=>{\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && isString(key)) {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n};\nconst regexSafe = (val)=>val.replace(/\\$/g, \"$$$$\");\nclass Interpolator {\n    constructor(options1 = {}){\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options1;\n        this.format = options1?.interpolation?.format || ((value)=>value);\n        this.init(options1);\n    }\n    init(options1 = {}) {\n        if (!options1.interpolation) options1.interpolation = {\n            escapeValue: true\n        };\n        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options1.interpolation;\n        this.escape = escape$1 !== undefined ? escape$1 : escape;\n        this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || \"{{\";\n        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || \"}}\";\n        this.formatSeparator = formatSeparator || \",\";\n        this.unescapePrefix = unescapeSuffix ? \"\" : unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : unescapeSuffix || \"\";\n        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = nestingOptionsSeparator || \",\";\n        this.maxReplaces = maxReplaces || 1000;\n        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const getOrResetRegExp = (existingRegExp, pattern)=>{\n            if (existingRegExp?.source === pattern) {\n                existingRegExp.lastIndex = 0;\n                return existingRegExp;\n            }\n            return new RegExp(pattern, \"g\");\n        };\n        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);\n    }\n    interpolate(str, data, lng, options1) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options1,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options1,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options1?.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options1?.interpolation?.skipOnVariables !== undefined ? options1.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options1);\n                        value = isString(temp) ? temp : \"\";\n                    } else if (options1 && Object.prototype.hasOwnProperty.call(options1, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (!isString(value) && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc, options1 = {}) {\n        let match;\n        let value;\n        let clonedOptions;\n        const handleHasOptions = (key, inheritedOptions)=>{\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n            return key;\n        };\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options1\n            };\n            clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf(\"}\") + 1 : match[1].indexOf(this.formatSeparator);\n            if (keyEndIndex !== -1) {\n                formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem)=>elem.trim()).filter(Boolean);\n                match[1] = match[1].slice(0, keyEndIndex);\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && !isString(value)) return value;\n            if (!isString(value)) value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (formatters.length) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options1.lng, {\n                        ...options1,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nconst parseFormatStr = (formatStr)=>{\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (opt) {\n                    const [key, ...rest] = opt.split(\":\");\n                    const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                    const trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === \"false\") formatOptions[trimmedKey] = false;\n                    if (val === \"true\") formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n};\nconst createCachedFormatter = (fn)=>{\n    const cache = {};\n    return (v, l, o)=>{\n        let optForCache = o;\n        if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {\n            optForCache = {\n                ...optForCache,\n                [o.interpolationkey]: undefined\n            };\n        }\n        const key = l + JSON.stringify(optForCache);\n        let frm = cache[key];\n        if (!frm) {\n            frm = fn(getCleanedCode(l), o);\n            cache[key] = frm;\n        }\n        return frm(v);\n    };\n};\nconst createNonCachedFormatter = (fn)=>(v, l, o)=>fn(getCleanedCode(l), o)(v);\nclass Formatter {\n    constructor(options1 = {}){\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options1;\n        this.init(options1);\n    }\n    init(services, options1 = {\n        interpolation: {}\n    }) {\n        this.formatSeparator = options1.interpolation.formatSeparator || \",\";\n        const cf = options1.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;\n        this.formats = {\n            number: cf((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: cf((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: cf((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: cf((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: cf((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng, options1 = {}) {\n        const formats = format.split(this.formatSeparator);\n        if (formats.length > 1 && formats[0].indexOf(\"(\") > 1 && formats[0].indexOf(\")\") < 0 && formats.find((f)=>f.indexOf(\")\") > -1)) {\n            const lastIndex = formats.findIndex((f)=>f.indexOf(\")\") > -1);\n            formats[0] = [\n                formats[0],\n                ...formats.splice(1, lastIndex)\n            ].join(this.formatSeparator);\n        }\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options1?.formatParams?.[options1.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options1.locale || options1.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options1,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nconst removePending = (q, name)=>{\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n};\nclass Connector extends EventEmitter {\n    constructor(backend, store, services, options1 = {}){\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options1;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options1.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options1.maxRetries >= 0 ? options1.maxRetries : 5;\n        this.retryTimeout = options1.retryTimeout >= 1 ? options1.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        this.backend?.init?.(services, options1.backend, options1);\n    }\n    queueLoad(languages, namespaces, options1, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options1.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (!err && data) {\n            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                skipCopy: true\n            });\n        }\n        this.state[name] = err ? -1 : 2;\n        if (err && data) this.state[name] = 0;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces, options1 = {}, callback) {\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n        if (isString(namespaces)) namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options1, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name, prefix = \"\") {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate, options1 = {}, clb = ()=>{}) {\n        if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend?.create) {\n            const opts = {\n                ...options1,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nconst get = ()=>({\n        debug: false,\n        initAsync: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: (args)=>{\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (isString(args[1])) ret.defaultValue = args[1];\n            if (isString(args[2])) ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options1 = args[3] || args[2];\n                Object.keys(options1).forEach((key)=>{\n                    ret[key] = options1[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        },\n        cacheInBuiltFormats: true\n    });\nconst transformOptions = (options1)=>{\n    if (isString(options1.ns)) options1.ns = [\n        options1.ns\n    ];\n    if (isString(options1.fallbackLng)) options1.fallbackLng = [\n        options1.fallbackLng\n    ];\n    if (isString(options1.fallbackNS)) options1.fallbackNS = [\n        options1.fallbackNS\n    ];\n    if (options1.supportedLngs?.indexOf?.(\"cimode\") < 0) {\n        options1.supportedLngs = options1.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    if (typeof options1.initImmediate === \"boolean\") options1.initAsync = options1.initImmediate;\n    return options1;\n};\nconst noop = ()=>{};\nconst bindMemberFunctions = (inst)=>{\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n};\nclass I18n extends EventEmitter {\n    constructor(options1 = {}, callback){\n        super();\n        this.options = transformOptions(options1);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options1.isClone) {\n            if (!this.options.initAsync) {\n                this.init(options1, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options1, callback);\n            }, 0);\n        }\n    }\n    init(options1 = {}, callback) {\n        this.isInitializing = true;\n        if (typeof options1 === \"function\") {\n            callback = options1;\n            options1 = {};\n        }\n        if (options1.defaultNS == null && options1.ns) {\n            if (isString(options1.ns)) {\n                options1.defaultNS = options1.ns;\n            } else if (options1.ns.indexOf(\"translation\") < 0) {\n                options1.defaultNS = options1.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options1)\n        };\n        this.options.interpolation = {\n            ...defOpts.interpolation,\n            ...this.options.interpolation\n        };\n        if (options1.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options1.keySeparator;\n        }\n        if (options1.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options1.nsSeparator;\n        }\n        const createClassOnDemand = (ClassOrObject)=>{\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        };\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;\n            if (usingLegacyFormatFunction) {\n                this.logger.warn(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);\n            }\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                if (s.formatter.init) s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", (event, ...args)=>{\n                this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", (event, ...args)=>{\n                this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = (...args)=>this.store[fcName](...args);\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = (...args)=>{\n                this.store[fcName](...args);\n                return this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                this.isInitializing = false;\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initAsync) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language, callback = noop) {\n        let usedCallback = callback;\n        const usedLng = isString(language) ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng?.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            this.options.preload?.forEach?.((l)=>append(l));\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"function\") {\n            callback = lngs;\n            lngs = undefined;\n        }\n        if (typeof ns === \"function\") {\n            callback = ns;\n            ns = undefined;\n        }\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n        if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {\n            this.resolvedLanguage = l;\n            this.languages.unshift(l);\n        }\n    }\n    changeLanguage(lng, callback) {\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                if (this.isLanguageChangingTo === lng) {\n                    setLngProps(l);\n                    this.translator.changeLanguage(l);\n                    this.isLanguageChangingTo = undefined;\n                    this.emit(\"languageChanged\", l);\n                    this.logger.log(\"languageChanged\", l);\n                }\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve((...args)=>this.t(...args));\n            if (callback) callback(err, (...args)=>this.t(...args));\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const fl = isString(lngs) ? lngs : lngs && lngs[0];\n            const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [\n                lngs\n            ] : lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                this.services.languageDetector?.cacheUserLanguage?.(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        const fixedT = (key, opts, ...rest)=>{\n            let o;\n            if (typeof opts !== \"object\") {\n                o = this.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                o = {\n                    ...opts\n                };\n            }\n            o.lng = o.lng || fixedT.lng;\n            o.lngs = o.lngs || fixedT.lngs;\n            o.ns = o.ns || fixedT.ns;\n            if (o.keyPrefix !== \"\") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = this.options.keySeparator || \".\";\n            let resultKey;\n            if (o.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${o.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return this.t(resultKey, o);\n        };\n        if (isString(lng)) {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t(...args) {\n        return this.translator?.translate(...args);\n    }\n    exists(...args) {\n        return this.translator?.exists(...args);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns, options1 = {}) {\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options1.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 0 || loadState === 2;\n        };\n        if (options1.precheck) {\n            const preResult = options1.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (isString(ns)) ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (isString(lngs)) lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        if (Intl.Locale) {\n            const l = new Intl.Locale(lng);\n            if (l && l.getTextInfo) {\n                const ti = l.getTextInfo();\n                if (ti && ti.direction) return ti.direction;\n            }\n        }\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services?.languageUtils || new LanguageUtil(get());\n        if (lng.toLowerCase().indexOf(\"-latn\") > 1) return \"ltr\";\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance(options1 = {}, callback) {\n        return new I18n(options1, callback);\n    }\n    cloneInstance(options1 = {}, callback = noop) {\n        const forkResourceStore = options1.forkResourceStore;\n        if (forkResourceStore) delete options1.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options1,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options1.debug !== undefined || options1.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options1);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            const clonedData = Object.keys(this.store.data).reduce((prev, l)=>{\n                prev[l] = {\n                    ...this.store.data[l]\n                };\n                prev[l] = Object.keys(prev[l]).reduce((acc, n)=>{\n                    acc[n] = {\n                        ...prev[l][n]\n                    };\n                    return acc;\n                }, prev[l]);\n                return prev;\n            }, {});\n            clone.store = new ResourceStore(clonedData, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", (event, ...args)=>{\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFdBQVdDLENBQUFBLE1BQU8sT0FBT0EsUUFBUTtBQUN2QyxNQUFNQyxRQUFRO0lBQ1osSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU1DLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUNwQ0wsTUFBTUk7UUFDTkgsTUFBTUk7SUFDUjtJQUNBSCxRQUFRRSxPQUFPLEdBQUdKO0lBQ2xCRSxRQUFRRyxNQUFNLEdBQUdKO0lBQ2pCLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNSSxhQUFhQyxDQUFBQTtJQUNqQixJQUFJQSxVQUFVLE1BQU0sT0FBTztJQUMzQixPQUFPLEtBQUtBO0FBQ2Q7QUFDQSxNQUFNQyxPQUFPLENBQUNDLEdBQUdDLEdBQUdDO0lBQ2xCRixFQUFFRyxPQUFPLENBQUNDLENBQUFBO1FBQ1IsSUFBSUgsQ0FBQyxDQUFDRyxFQUFFLEVBQUVGLENBQUMsQ0FBQ0UsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDdkI7QUFDRjtBQUNBLE1BQU1DLDRCQUE0QjtBQUNsQyxNQUFNQyxXQUFXQyxDQUFBQSxNQUFPQSxPQUFPQSxJQUFJQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUlELElBQUlFLE9BQU8sQ0FBQ0osMkJBQTJCLE9BQU9FO0FBQ3ZHLE1BQU1HLHVCQUF1QlosQ0FBQUEsU0FBVSxDQUFDQSxVQUFVVixTQUFTVTtBQUMzRCxNQUFNYSxnQkFBZ0IsQ0FBQ2IsUUFBUWMsTUFBTUM7SUFDbkMsTUFBTUMsUUFBUSxDQUFDMUIsU0FBU3dCLFFBQVFBLE9BQU9BLEtBQUtHLEtBQUssQ0FBQztJQUNsRCxJQUFJQyxhQUFhO0lBQ2pCLE1BQU9BLGFBQWFGLE1BQU1HLE1BQU0sR0FBRyxFQUFHO1FBQ3BDLElBQUlQLHFCQUFxQlosU0FBUyxPQUFPLENBQUM7UUFDMUMsTUFBTVMsTUFBTUQs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QyxTQUFTOUMsYUFBYTtBQUM1QyxNQUFNSyxrQkFBa0J5QyxTQUFTekMsZUFBZTtBQUNoRCxNQUFNQyxNQUFNd0MsU0FBU3hDLEdBQUc7QUFDeEIsTUFBTTFWLGlCQUFpQmtZLFNBQVNsWSxjQUFjO0FBQzlDLE1BQU1zVyxZQUFZNEIsU0FBUzVCLFNBQVM7QUFDcEMsTUFBTWhoQixJQUFJNGlCLFNBQVM1aUIsQ0FBQztBQUNwQixNQUFNNEssU0FBU2dZLFNBQVNoWSxNQUFNO0FBQzlCLE1BQU13VyxzQkFBc0J3QixTQUFTeEIsbUJBQW1CO0FBQ3hELE1BQU1oUSxxQkFBcUJ3UixTQUFTeFIsa0JBQWtCO0FBQ3RELE1BQU1zUSxpQkFBaUJrQixTQUFTbEIsY0FBYztBQUM5QyxNQUFNQyxnQkFBZ0JpQixTQUFTakIsYUFBYTtBQUVpSyIsInNvdXJjZXMiOlsid2VicGFjazovL2l3YXRlLWR4LXVuaWZpZWQtc3lzdGVtLy4vbm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9lc20vaTE4bmV4dC5qcz82OGU1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzU3RyaW5nID0gb2JqID0+IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuY29uc3QgZGVmZXIgPSAoKSA9PiB7XG4gIGxldCByZXM7XG4gIGxldCByZWo7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZTtcbiAgICByZWogPSByZWplY3Q7XG4gIH0pO1xuICBwcm9taXNlLnJlc29sdmUgPSByZXM7XG4gIHByb21pc2UucmVqZWN0ID0gcmVqO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG5jb25zdCBtYWtlU3RyaW5nID0gb2JqZWN0ID0+IHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gJyc7XG4gIHJldHVybiAnJyArIG9iamVjdDtcbn07XG5jb25zdCBjb3B5ID0gKGEsIHMsIHQpID0+IHtcbiAgYS5mb3JFYWNoKG0gPT4ge1xuICAgIGlmIChzW21dKSB0W21dID0gc1ttXTtcbiAgfSk7XG59O1xuY29uc3QgbGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCA9IC8jIyMvZztcbmNvbnN0IGNsZWFuS2V5ID0ga2V5ID0+IGtleSAmJiBrZXkuaW5kZXhPZignIyMjJykgPiAtMSA/IGtleS5yZXBsYWNlKGxhc3RPZlBhdGhTZXBhcmF0b3JSZWdFeHAsICcuJykgOiBrZXk7XG5jb25zdCBjYW5Ob3RUcmF2ZXJzZURlZXBlciA9IG9iamVjdCA9PiAhb2JqZWN0IHx8IGlzU3RyaW5nKG9iamVjdCk7XG5jb25zdCBnZXRMYXN0T2ZQYXRoID0gKG9iamVjdCwgcGF0aCwgRW1wdHkpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSAhaXNTdHJpbmcocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgc3RhY2tJbmRleCA9IDA7XG4gIHdoaWxlIChzdGFja0luZGV4IDwgc3RhY2subGVuZ3RoIC0gMSkge1xuICAgIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcihvYmplY3QpKSByZXR1cm4ge307XG4gICAgY29uc3Qga2V5ID0gY2xlYW5LZXkoc3RhY2tbc3RhY2tJbmRleF0pO1xuICAgIGlmICghb2JqZWN0W2tleV0gJiYgRW1wdHkpIG9iamVjdFtrZXldID0gbmV3IEVtcHR5KCk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSB7fTtcbiAgICB9XG4gICAgKytzdGFja0luZGV4O1xuICB9XG4gIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcihvYmplY3QpKSByZXR1cm4ge307XG4gIHJldHVybiB7XG4gICAgb2JqOiBvYmplY3QsXG4gICAgazogY2xlYW5LZXkoc3RhY2tbc3RhY2tJbmRleF0pXG4gIH07XG59O1xuY29uc3Qgc2V0UGF0aCA9IChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCB8fCBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIG9ialtrXSA9IG5ld1ZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgbGV0IHAgPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gIGxldCBsYXN0ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHAsIE9iamVjdCk7XG4gIHdoaWxlIChsYXN0Lm9iaiA9PT0gdW5kZWZpbmVkICYmIHAubGVuZ3RoKSB7XG4gICAgZSA9IGAke3BbcC5sZW5ndGggLSAxXX0uJHtlfWA7XG4gICAgcCA9IHAuc2xpY2UoMCwgcC5sZW5ndGggLSAxKTtcbiAgICBsYXN0ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHAsIE9iamVjdCk7XG4gICAgaWYgKGxhc3Q/Lm9iaiAmJiB0eXBlb2YgbGFzdC5vYmpbYCR7bGFzdC5rfS4ke2V9YF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsYXN0Lm9iaiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgbGFzdC5vYmpbYCR7bGFzdC5rfS4ke2V9YF0gPSBuZXdWYWx1ZTtcbn07XG5jb25zdCBwdXNoUGF0aCA9IChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlLCBjb25jYXQpID0+IHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KTtcbiAgb2JqW2tdID0gb2JqW2tdIHx8IFtdO1xuICBvYmpba10ucHVzaChuZXdWYWx1ZSk7XG59O1xuY29uc3QgZ2V0UGF0aCA9IChvYmplY3QsIHBhdGgpID0+IHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCk7XG4gIGlmICghb2JqKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gb2JqW2tdO1xufTtcbmNvbnN0IGdldFBhdGhXaXRoRGVmYXVsdHMgPSAoZGF0YSwgZGVmYXVsdERhdGEsIGtleSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGdldFBhdGgoZGF0YSwga2V5KTtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdldFBhdGgoZGVmYXVsdERhdGEsIGtleSk7XG59O1xuY29uc3QgZGVlcEV4dGVuZCA9ICh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSA9PiB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICBpZiAocHJvcCAhPT0gJ19fcHJvdG9fXycgJiYgcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpc1N0cmluZyh0YXJnZXRbcHJvcF0pIHx8IHRhcmdldFtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZyB8fCBpc1N0cmluZyhzb3VyY2VbcHJvcF0pIHx8IHNvdXJjZVtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuY29uc3QgcmVnZXhFc2NhcGUgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG52YXIgX2VudGl0eU1hcCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJy8nOiAnJiN4MkY7J1xufTtcbmNvbnN0IGVzY2FwZSA9IGRhdGEgPT4ge1xuICBpZiAoaXNTdHJpbmcoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKC9bJjw+XCInXFwvXS9nLCBzID0+IF9lbnRpdHlNYXBbc10pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufTtcbmNsYXNzIFJlZ0V4cENhY2hlIHtcbiAgY29uc3RydWN0b3IoY2FwYWNpdHkpIHtcbiAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5yZWdFeHBNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWdFeHBRdWV1ZSA9IFtdO1xuICB9XG4gIGdldFJlZ0V4cChwYXR0ZXJuKSB7XG4gICAgY29uc3QgcmVnRXhwRnJvbUNhY2hlID0gdGhpcy5yZWdFeHBNYXAuZ2V0KHBhdHRlcm4pO1xuICAgIGlmIChyZWdFeHBGcm9tQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlZ0V4cEZyb21DYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcmVnRXhwTmV3ID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICBpZiAodGhpcy5yZWdFeHBRdWV1ZS5sZW5ndGggPT09IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgIHRoaXMucmVnRXhwTWFwLmRlbGV0ZSh0aGlzLnJlZ0V4cFF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgICB0aGlzLnJlZ0V4cE1hcC5zZXQocGF0dGVybiwgcmVnRXhwTmV3KTtcbiAgICB0aGlzLnJlZ0V4cFF1ZXVlLnB1c2gocGF0dGVybik7XG4gICAgcmV0dXJuIHJlZ0V4cE5ldztcbiAgfVxufVxuY29uc3QgY2hhcnMgPSBbJyAnLCAnLCcsICc/JywgJyEnLCAnOyddO1xuY29uc3QgbG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlID0gbmV3IFJlZ0V4cENhY2hlKDIwKTtcbmNvbnN0IGxvb2tzTGlrZU9iamVjdFBhdGggPSAoa2V5LCBuc1NlcGFyYXRvciwga2V5U2VwYXJhdG9yKSA9PiB7XG4gIG5zU2VwYXJhdG9yID0gbnNTZXBhcmF0b3IgfHwgJyc7XG4gIGtleVNlcGFyYXRvciA9IGtleVNlcGFyYXRvciB8fCAnJztcbiAgY29uc3QgcG9zc2libGVDaGFycyA9IGNoYXJzLmZpbHRlcihjID0+IG5zU2VwYXJhdG9yLmluZGV4T2YoYykgPCAwICYmIGtleVNlcGFyYXRvci5pbmRleE9mKGMpIDwgMCk7XG4gIGlmIChwb3NzaWJsZUNoYXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHIgPSBsb29rc0xpa2VPYmplY3RQYXRoUmVnRXhwQ2FjaGUuZ2V0UmVnRXhwKGAoJHtwb3NzaWJsZUNoYXJzLm1hcChjID0+IGMgPT09ICc/JyA/ICdcXFxcPycgOiBjKS5qb2luKCd8Jyl9KWApO1xuICBsZXQgbWF0Y2hlZCA9ICFyLnRlc3Qoa2V5KTtcbiAgaWYgKCFtYXRjaGVkKSB7XG4gICAgY29uc3Qga2kgPSBrZXkuaW5kZXhPZihrZXlTZXBhcmF0b3IpO1xuICAgIGlmIChraSA+IDAgJiYgIXIudGVzdChrZXkuc3Vic3RyaW5nKDAsIGtpKSkpIHtcbiAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlZDtcbn07XG5jb25zdCBkZWVwRmluZCA9IChvYmosIHBhdGgsIGtleVNlcGFyYXRvciA9ICcuJykgPT4ge1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKG9ialtwYXRoXSkge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcGF0aCkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG9ialtwYXRoXTtcbiAgfVxuICBjb25zdCB0b2tlbnMgPSBwYXRoLnNwbGl0KGtleVNlcGFyYXRvcik7XG4gIGxldCBjdXJyZW50ID0gb2JqO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7KSB7XG4gICAgaWYgKCFjdXJyZW50IHx8IHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG5leHQ7XG4gICAgbGV0IG5leHRQYXRoID0gJyc7XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCB0b2tlbnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChqICE9PSBpKSB7XG4gICAgICAgIG5leHRQYXRoICs9IGtleVNlcGFyYXRvcjtcbiAgICAgIH1cbiAgICAgIG5leHRQYXRoICs9IHRva2Vuc1tqXTtcbiAgICAgIG5leHQgPSBjdXJyZW50W25leHRQYXRoXTtcbiAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ10uaW5kZXhPZih0eXBlb2YgbmV4dCkgPiAtMSAmJiBqIDwgdG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpICs9IGogLSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJlbnQgPSBuZXh0O1xuICB9XG4gIHJldHVybiBjdXJyZW50O1xufTtcbmNvbnN0IGdldENsZWFuZWRDb2RlID0gY29kZSA9PiBjb2RlPy5yZXBsYWNlKCdfJywgJy0nKTtcblxuY29uc3QgY29uc29sZUxvZ2dlciA9IHtcbiAgdHlwZTogJ2xvZ2dlcicsXG4gIGxvZyhhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ2xvZycsIGFyZ3MpO1xuICB9LFxuICB3YXJuKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnd2FybicsIGFyZ3MpO1xuICB9LFxuICBlcnJvcihhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ2Vycm9yJywgYXJncyk7XG4gIH0sXG4gIG91dHB1dCh0eXBlLCBhcmdzKSB7XG4gICAgY29uc29sZT8uW3R5cGVdPy5hcHBseT8uKGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uY3JldGVMb2dnZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuaW5pdChjb25jcmV0ZUxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbiAgaW5pdChjb25jcmV0ZUxvZ2dlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCAnaTE4bmV4dDonO1xuICAgIHRoaXMubG9nZ2VyID0gY29uY3JldGVMb2dnZXIgfHwgY29uc29sZUxvZ2dlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICB9XG4gIGxvZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnbG9nJywgJycsIHRydWUpO1xuICB9XG4gIHdhcm4oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ3dhcm4nLCAnJywgdHJ1ZSk7XG4gIH1cbiAgZXJyb3IoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ2Vycm9yJywgJycpO1xuICB9XG4gIGRlcHJlY2F0ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICdXQVJOSU5HIERFUFJFQ0FURUQ6ICcsIHRydWUpO1xuICB9XG4gIGZvcndhcmQoYXJncywgbHZsLCBwcmVmaXgsIGRlYnVnT25seSkge1xuICAgIGlmIChkZWJ1Z09ubHkgJiYgIXRoaXMuZGVidWcpIHJldHVybiBudWxsO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzBdKSkgYXJnc1swXSA9IGAke3ByZWZpeH0ke3RoaXMucHJlZml4fSAke2FyZ3NbMF19YDtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJbbHZsXShhcmdzKTtcbiAgfVxuICBjcmVhdGUobW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCB7XG4gICAgICAuLi57XG4gICAgICAgIHByZWZpeDogYCR7dGhpcy5wcmVmaXh9OiR7bW9kdWxlTmFtZX06YFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNsb25lKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnM7XG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCB0aGlzLnByZWZpeDtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbn1cbnZhciBiYXNlTG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50cywgbGlzdGVuZXIpIHtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB0aGlzLm9ic2VydmVyc1tldmVudF0gPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBudW1MaXN0ZW5lcnMgPSB0aGlzLm9ic2VydmVyc1tldmVudF0uZ2V0KGxpc3RlbmVyKSB8fCAwO1xuICAgICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdLnNldChsaXN0ZW5lciwgbnVtTGlzdGVuZXJzICsgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSByZXR1cm47XG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGlmICh0aGlzLm9ic2VydmVyc1tldmVudF0pIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlcnNbZXZlbnRdLmVudHJpZXMoKSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaCgoW29ic2VydmVyLCBudW1UaW1lc0FkZGVkXSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzQWRkZWQ7IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzWycqJ10pIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlcnNbJyonXS5lbnRyaWVzKCkpO1xuICAgICAgY2xvbmVkLmZvckVhY2goKFtvYnNlcnZlciwgbnVtVGltZXNBZGRlZF0pID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lc0FkZGVkOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlci5hcHBseShvYnNlcnZlciwgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZXNvdXJjZVN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHtcbiAgICBuczogWyd0cmFuc2xhdGlvbiddLFxuICAgIGRlZmF1bHROUzogJ3RyYW5zbGF0aW9uJ1xuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYWRkTmFtZXNwYWNlcyhucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihucykgPCAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMucHVzaChucyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU5hbWVzcGFjZXMobnMpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5vcHRpb25zLm5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIGdldFJlc291cmNlKGxuZywgbnMsIGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBjb25zdCBpZ25vcmVKU09OU3RydWN0dXJlID0gb3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgOiB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZTtcbiAgICBsZXQgcGF0aDtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBbbG5nLCBuc107XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICBwYXRoLnB1c2goLi4ua2V5KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhrZXkpICYmIGtleVNlcGFyYXRvcikge1xuICAgICAgICAgIHBhdGgucHVzaCguLi5rZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgpO1xuICAgIGlmICghcmVzdWx0ICYmICFucyAmJiAha2V5ICYmIGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgbG5nID0gcGF0aFswXTtcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICAgIGtleSA9IHBhdGguc2xpY2UoMikuam9pbignLicpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IHx8ICFpZ25vcmVKU09OU3RydWN0dXJlIHx8ICFpc1N0cmluZyhrZXkpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBkZWVwRmluZCh0aGlzLmRhdGE/LltsbmddPy5bbnNdLCBrZXksIGtleVNlcGFyYXRvcik7XG4gIH1cbiAgYWRkUmVzb3VyY2UobG5nLCBucywga2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHtcbiAgICBzaWxlbnQ6IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChrZXkpIHBhdGggPSBwYXRoLmNvbmNhdChrZXlTZXBhcmF0b3IgPyBrZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSA6IGtleSk7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgICAgdmFsdWUgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBzZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgdmFsdWUpO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCBrZXksIHZhbHVlKTtcbiAgfVxuICBhZGRSZXNvdXJjZXMobG5nLCBucywgcmVzb3VyY2VzLCBvcHRpb25zID0ge1xuICAgIHNpbGVudDogZmFsc2VcbiAgfSkge1xuICAgIGZvciAoY29uc3QgbSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGlmIChpc1N0cmluZyhyZXNvdXJjZXNbbV0pIHx8IEFycmF5LmlzQXJyYXkocmVzb3VyY2VzW21dKSkgdGhpcy5hZGRSZXNvdXJjZShsbmcsIG5zLCBtLCByZXNvdXJjZXNbbV0sIHtcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIHJlc291cmNlcyk7XG4gIH1cbiAgYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgcmVzb3VyY2VzLCBkZWVwLCBvdmVyd3JpdGUsIG9wdGlvbnMgPSB7XG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICBza2lwQ29weTogZmFsc2VcbiAgfSkge1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIGRlZXAgPSByZXNvdXJjZXM7XG4gICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBsZXQgcGFjayA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKSB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcENvcHkpIHJlc291cmNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzb3VyY2VzKSk7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGRlZXBFeHRlbmQocGFjaywgcmVzb3VyY2VzLCBvdmVyd3JpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrID0ge1xuICAgICAgICAuLi5wYWNrLFxuICAgICAgICAuLi5yZXNvdXJjZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCBwYWNrKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICByZW1vdmVSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKHRoaXMuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbbG5nXVtuc107XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlTmFtZXNwYWNlcyhucyk7XG4gICAgdGhpcy5lbWl0KCdyZW1vdmVkJywgbG5nLCBucyk7XG4gIH1cbiAgaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0UmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLmRlZmF1bHROUztcbiAgICByZXR1cm4gdGhpcy5nZXRSZXNvdXJjZShsbmcsIG5zKTtcbiAgfVxuICBnZXREYXRhQnlMYW5ndWFnZShsbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2xuZ107XG4gIH1cbiAgaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zKGxuZykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFCeUxhbmd1YWdlKGxuZyk7XG4gICAgY29uc3QgbiA9IGRhdGEgJiYgT2JqZWN0LmtleXMoZGF0YSkgfHwgW107XG4gICAgcmV0dXJuICEhbi5maW5kKHYgPT4gZGF0YVt2XSAmJiBPYmplY3Qua2V5cyhkYXRhW3ZdKS5sZW5ndGggPiAwKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufVxuXG52YXIgcG9zdFByb2Nlc3NvciA9IHtcbiAgcHJvY2Vzc29yczoge30sXG4gIGFkZFBvc3RQcm9jZXNzb3IobW9kdWxlKSB7XG4gICAgdGhpcy5wcm9jZXNzb3JzW21vZHVsZS5uYW1lXSA9IG1vZHVsZTtcbiAgfSxcbiAgaGFuZGxlKHByb2Nlc3NvcnMsIHZhbHVlLCBrZXksIG9wdGlvbnMsIHRyYW5zbGF0b3IpIHtcbiAgICBwcm9jZXNzb3JzLmZvckVhY2gocHJvY2Vzc29yID0+IHtcbiAgICAgIHZhbHVlID0gdGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0/LnByb2Nlc3ModmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcikgPz8gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5jb25zdCBjaGVja2VkTG9hZGVkRm9yID0ge307XG5jb25zdCBzaG91bGRIYW5kbGVBc09iamVjdCA9IHJlcyA9PiAhaXNTdHJpbmcocmVzKSAmJiB0eXBlb2YgcmVzICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIHJlcyAhPT0gJ251bWJlcic7XG5jbGFzcyBUcmFuc2xhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc2VydmljZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29weShbJ3Jlc291cmNlU3RvcmUnLCAnbGFuZ3VhZ2VVdGlscycsICdwbHVyYWxSZXNvbHZlcicsICdpbnRlcnBvbGF0b3InLCAnYmFja2VuZENvbm5lY3RvcicsICdpMThuRm9ybWF0JywgJ3V0aWxzJ10sIHNlcnZpY2VzLCB0aGlzKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPSAnLic7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ3RyYW5zbGF0b3InKTtcbiAgfVxuICBjaGFuZ2VMYW5ndWFnZShsbmcpIHtcbiAgICBpZiAobG5nKSB0aGlzLmxhbmd1YWdlID0gbG5nO1xuICB9XG4gIGV4aXN0cyhrZXksIG8gPSB7XG4gICAgaW50ZXJwb2xhdGlvbjoge31cbiAgfSkge1xuICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgIC4uLm9cbiAgICB9O1xuICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKGtleSwgb3B0KTtcbiAgICByZXR1cm4gcmVzb2x2ZWQ/LnJlcyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGV4dHJhY3RGcm9tS2V5KGtleSwgb3B0KSB7XG4gICAgbGV0IG5zU2VwYXJhdG9yID0gb3B0Lm5zU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHQubnNTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgaWYgKG5zU2VwYXJhdG9yID09PSB1bmRlZmluZWQpIG5zU2VwYXJhdG9yID0gJzonO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdC5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdC5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBuYW1lc3BhY2VzID0gb3B0Lm5zIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgfHwgW107XG4gICAgY29uc3Qgd291bGRDaGVja0Zvck5zSW5LZXkgPSBuc1NlcGFyYXRvciAmJiBrZXkuaW5kZXhPZihuc1NlcGFyYXRvcikgPiAtMTtcbiAgICBjb25zdCBzZWVtc05hdHVyYWxMYW5ndWFnZSA9ICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgJiYgIW9wdC5rZXlTZXBhcmF0b3IgJiYgIXRoaXMub3B0aW9ucy51c2VyRGVmaW5lZE5zU2VwYXJhdG9yICYmICFvcHQubnNTZXBhcmF0b3IgJiYgIWxvb2tzTGlrZU9iamVjdFBhdGgoa2V5LCBuc1NlcGFyYXRvciwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAod291bGRDaGVja0Zvck5zSW5LZXkgJiYgIXNlZW1zTmF0dXJhbExhbmd1YWdlKSB7XG4gICAgICBjb25zdCBtID0ga2V5Lm1hdGNoKHRoaXMuaW50ZXJwb2xhdG9yLm5lc3RpbmdSZWdleHApO1xuICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5hbWVzcGFjZXM6IGlzU3RyaW5nKG5hbWVzcGFjZXMpID8gW25hbWVzcGFjZXNdIDogbmFtZXNwYWNlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQobnNTZXBhcmF0b3IpO1xuICAgICAgaWYgKG5zU2VwYXJhdG9yICE9PSBrZXlTZXBhcmF0b3IgfHwgbnNTZXBhcmF0b3IgPT09IGtleVNlcGFyYXRvciAmJiB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihwYXJ0c1swXSkgPiAtMSkgbmFtZXNwYWNlcyA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBrZXkgPSBwYXJ0cy5qb2luKGtleVNlcGFyYXRvcik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzOiBpc1N0cmluZyhuYW1lc3BhY2VzKSA/IFtuYW1lc3BhY2VzXSA6IG5hbWVzcGFjZXNcbiAgICB9O1xuICB9XG4gIHRyYW5zbGF0ZShrZXlzLCBvLCBsYXN0S2V5KSB7XG4gICAgbGV0IG9wdCA9IHR5cGVvZiBvID09PSAnb2JqZWN0JyA/IHtcbiAgICAgIC4uLm9cbiAgICB9IDogbztcbiAgICBpZiAodHlwZW9mIG9wdCAhPT0gJ29iamVjdCcgJiYgdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKSB7XG4gICAgICBvcHQgPSB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykgb3B0ID0ge1xuICAgICAgLi4ub3B0XG4gICAgfTtcbiAgICBpZiAoIW9wdCkgb3B0ID0ge307XG4gICAgaWYgKGtleXMgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHQucmV0dXJuRGV0YWlscyAhPT0gdW5kZWZpbmVkID8gb3B0LnJldHVybkRldGFpbHMgOiB0aGlzLm9wdGlvbnMucmV0dXJuRGV0YWlscztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHQua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHQua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzXG4gICAgfSA9IHRoaXMuZXh0cmFjdEZyb21LZXkoa2V5c1trZXlzLmxlbmd0aCAtIDFdLCBvcHQpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHQubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdC5uc1NlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICBpZiAobnNTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgbnNTZXBhcmF0b3IgPSAnOic7XG4gICAgY29uc3QgbG5nID0gb3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlO1xuICAgIGNvbnN0IGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlID0gb3B0LmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nPy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gO1xuICAgICAgfVxuICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXM6IGtleSxcbiAgICAgICAgICB1c2VkS2V5OiBrZXksXG4gICAgICAgICAgZXhhY3RVc2VkS2V5OiBrZXksXG4gICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgIHVzZWROUzogbmFtZXNwYWNlLFxuICAgICAgICAgIHVzZWRQYXJhbXM6IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoa2V5cywgb3B0KTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQ/LnJlcztcbiAgICBjb25zdCByZXNVc2VkS2V5ID0gcmVzb2x2ZWQ/LnVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc0V4YWN0VXNlZEtleSA9IHJlc29sdmVkPy5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IG5vT2JqZWN0ID0gWydbb2JqZWN0IE51bWJlcl0nLCAnW29iamVjdCBGdW5jdGlvbl0nLCAnW29iamVjdCBSZWdFeHBdJ107XG4gICAgY29uc3Qgam9pbkFycmF5cyA9IG9wdC5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHQuam9pbkFycmF5cyA6IHRoaXMub3B0aW9ucy5qb2luQXJyYXlzO1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ID0gIXRoaXMuaTE4bkZvcm1hdCB8fCB0aGlzLmkxOG5Gb3JtYXQuaGFuZGxlQXNPYmplY3Q7XG4gICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdC5jb3VudCAhPT0gdW5kZWZpbmVkICYmICFpc1N0cmluZyhvcHQuY291bnQpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHRWYWx1ZSA9IFRyYW5zbGF0b3IuaGFzRGVmYXVsdFZhbHVlKG9wdCk7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4ID0gbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0LmNvdW50LCBvcHQpIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0Lm9yZGluYWwgJiYgbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0LmNvdW50LCB7XG4gICAgICBvcmRpbmFsOiBmYWxzZVxuICAgIH0pIDogJyc7XG4gICAgY29uc3QgbmVlZHNaZXJvU3VmZml4TG9va3VwID0gbmVlZHNQbHVyYWxIYW5kbGluZyAmJiAhb3B0Lm9yZGluYWwgJiYgb3B0LmNvdW50ID09PSAwO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCAmJiBvcHRbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gfHwgb3B0W2BkZWZhdWx0VmFsdWUke2RlZmF1bHRWYWx1ZVN1ZmZpeH1gXSB8fCBvcHRbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdC5kZWZhdWx0VmFsdWU7XG4gICAgbGV0IHJlc0Zvck9iakhuZGwgPSByZXM7XG4gICAgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmICFyZXMgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXNGb3JPYmpIbmRsID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVBc09iamVjdCA9IHNob3VsZEhhbmRsZUFzT2JqZWN0KHJlc0Zvck9iakhuZGwpO1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlc0Zvck9iakhuZGwpO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXNGb3JPYmpIbmRsICYmIGhhbmRsZUFzT2JqZWN0ICYmIG5vT2JqZWN0LmluZGV4T2YocmVzVHlwZSkgPCAwICYmICEoaXNTdHJpbmcoam9pbkFycmF5cykgJiYgQXJyYXkuaXNBcnJheShyZXNGb3JPYmpIbmRsKSkpIHtcbiAgICAgIGlmICghb3B0LnJldHVybk9iamVjdHMgJiYgIXRoaXMub3B0aW9ucy5yZXR1cm5PYmplY3RzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2FjY2Vzc2luZyBhbiBvYmplY3QgLSBidXQgcmV0dXJuT2JqZWN0cyBvcHRpb25zIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcihyZXNVc2VkS2V5LCByZXNGb3JPYmpIbmRsLCB7XG4gICAgICAgICAgLi4ub3B0LFxuICAgICAgICAgIG5zOiBuYW1lc3BhY2VzXG4gICAgICAgIH0pIDogYGtleSAnJHtrZXl9ICgke3RoaXMubGFuZ3VhZ2V9KScgcmV0dXJuZWQgYW4gb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nLmA7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmVzb2x2ZWQucmVzID0gcjtcbiAgICAgICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzVHlwZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlc0Zvck9iakhuZGwpO1xuICAgICAgICBjb25zdCBjb3B5ID0gcmVzVHlwZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBjb25zdCBuZXdLZXlUb1VzZSA9IHJlc1R5cGVJc0FycmF5ID8gcmVzRXhhY3RVc2VkS2V5IDogcmVzVXNlZEtleTtcbiAgICAgICAgZm9yIChjb25zdCBtIGluIHJlc0Zvck9iakhuZGwpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc0Zvck9iakhuZGwsIG0pKSB7XG4gICAgICAgICAgICBjb25zdCBkZWVwS2V5ID0gYCR7bmV3S2V5VG9Vc2V9JHtrZXlTZXBhcmF0b3J9JHttfWA7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdFZhbHVlICYmICFyZXMpIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzaG91bGRIYW5kbGVBc09iamVjdChkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlW21dIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29weVttXSA9PT0gZGVlcEtleSkgY29weVttXSA9IHJlc0Zvck9iakhuZGxbbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGNvcHk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiBpc1N0cmluZyhqb2luQXJyYXlzKSAmJiBBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIHJlcyA9IHJlcy5qb2luKGpvaW5BcnJheXMpO1xuICAgICAgaWYgKHJlcykgcmVzID0gdGhpcy5leHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleXMsIG9wdCwgbGFzdEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1c2VkRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgbGV0IHVzZWRLZXkgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykgJiYgaGFzRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHVzZWREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSkge1xuICAgICAgICB1c2VkS2V5ID0gdHJ1ZTtcbiAgICAgICAgcmVzID0ga2V5O1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5ID0gb3B0Lm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICAgIGtleVNlcGFyYXRvcjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZmsgJiYgZmsucmVzKSB0aGlzLmxvZ2dlci53YXJuKCdTZWVtcyB0aGUgbG9hZGVkIHRyYW5zbGF0aW9ucyB3ZXJlIGluIGZsYXQgSlNPTiBmb3JtYXQgaW5zdGVhZCBvZiBuZXN0ZWQuIEVpdGhlciBzZXQga2V5U2VwYXJhdG9yOiBmYWxzZSBvbiBpbml0IG9yIG1ha2Ugc3VyZSB5b3VyIHRyYW5zbGF0aW9ucyBhcmUgcHVibGlzaGVkIGluIG5lc3RlZCBmb3JtYXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxuZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tMbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nLCBvcHQubG5nIHx8IHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgZmFsbGJhY2tMbmdzICYmIGZhbGxiYWNrTG5nc1swXSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFsbGJhY2tMbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsbmdzLnB1c2goZmFsbGJhY2tMbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdhbGwnKSB7XG4gICAgICAgICAgbG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kID0gKGwsIGssIHNwZWNpZmljRGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEZvck1pc3NpbmcgPSBoYXNEZWZhdWx0VmFsdWUgJiYgc3BlY2lmaWNEZWZhdWx0VmFsdWUgIT09IHJlcyA/IHNwZWNpZmljRGVmYXVsdFZhbHVlIDogcmVzRm9yTWlzc2luZztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWlzc2luZ0tleUhhbmRsZXIobCwgbmFtZXNwYWNlLCBrLCBkZWZhdWx0Rm9yTWlzc2luZywgdXBkYXRlTWlzc2luZywgb3B0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYmFja2VuZENvbm5lY3Rvcj8uc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZyhsLCBuYW1lc3BhY2UsIGssIGRlZmF1bHRGb3JNaXNzaW5nLCB1cGRhdGVNaXNzaW5nLCBvcHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4ZXMobGFuZ3VhZ2UsIG9wdCk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXAgJiYgb3B0W2BkZWZhdWx0VmFsdWUke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2BdICYmIHN1ZmZpeGVzLmluZGV4T2YoYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ZXMucHVzaChgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWZmaXhlcy5mb3JFYWNoKHN1ZmZpeCA9PiB7XG4gICAgICAgICAgICAgICAgc2VuZChbbGFuZ3VhZ2VdLCBrZXkgKyBzdWZmaXgsIG9wdFtgZGVmYXVsdFZhbHVlJHtzdWZmaXh9YF0gfHwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZChsbmdzLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0LCByZXNvbHZlZCwgbGFzdEtleSk7XG4gICAgICBpZiAodXNlZEtleSAmJiByZXMgPT09IGtleSAmJiB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5KSB7XG4gICAgICAgIHJlcyA9IGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICB9XG4gICAgICBpZiAoKHVzZWRLZXkgfHwgdXNlZERlZmF1bHQpICYmIHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkgPyBgJHtuYW1lc3BhY2V9JHtuc1NlcGFyYXRvcn0ke2tleX1gIDoga2V5LCB1c2VkRGVmYXVsdCA/IHJlcyA6IHVuZGVmaW5lZCwgb3B0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgIHJlc29sdmVkLnJlcyA9IHJlcztcbiAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdCk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXksIG9wdCwgcmVzb2x2ZWQsIGxhc3RLZXkpIHtcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0Py5wYXJzZSkge1xuICAgICAgcmVzID0gdGhpcy5pMThuRm9ybWF0LnBhcnNlKHJlcywge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5vcHRcbiAgICAgIH0sIG9wdC5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCByZXNvbHZlZC51c2VkTlMsIHJlc29sdmVkLnVzZWRLZXksIHtcbiAgICAgICAgcmVzb2x2ZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW9wdC5za2lwSW50ZXJwb2xhdGlvbikge1xuICAgICAgaWYgKG9wdC5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5pbml0KHtcbiAgICAgICAgLi4ub3B0LFxuICAgICAgICAuLi57XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAuLi5vcHQuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBpc1N0cmluZyhyZXMpICYmIChvcHQ/LmludGVycG9sYXRpb24/LnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0LmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXN0QmVmO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYiA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgbmVzdEJlZiA9IG5iICYmIG5iLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0gb3B0LnJlcGxhY2UgJiYgIWlzU3RyaW5nKG9wdC5yZXBsYWNlKSA/IG9wdC5yZXBsYWNlIDogb3B0O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICByZXMgPSB0aGlzLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShyZXMsIGRhdGEsIG9wdC5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCBvcHQpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHQubmVzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHQubG5nICYmIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcykgb3B0LmxuZyA9IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZztcbiAgICAgIGlmIChvcHQubmVzdCAhPT0gZmFsc2UpIHJlcyA9IHRoaXMuaW50ZXJwb2xhdG9yLm5lc3QocmVzLCAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAobGFzdEtleT8uWzBdID09PSBhcmdzWzBdICYmICFvcHQuY29udGV4dCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEl0IHNlZW1zIHlvdSBhcmUgbmVzdGluZyByZWN1cnNpdmVseSBrZXk6ICR7YXJnc1swXX0gaW4ga2V5OiAke2tleVswXX1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdCk7XG4gICAgICBpZiAob3B0LmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLnJlc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gb3B0LnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSBpc1N0cmluZyhwb3N0UHJvY2VzcykgPyBbcG9zdFByb2Nlc3NdIDogcG9zdFByb2Nlc3M7XG4gICAgaWYgKHJlcyAhPSBudWxsICYmIHBvc3RQcm9jZXNzb3JOYW1lcz8ubGVuZ3RoICYmIG9wdC5hcHBseVBvc3RQcm9jZXNzb3IgIT09IGZhbHNlKSB7XG4gICAgICByZXMgPSBwb3N0UHJvY2Vzc29yLmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkID8ge1xuICAgICAgICBpMThuUmVzb2x2ZWQ6IHtcbiAgICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdClcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0XG4gICAgICB9IDogb3B0LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXNvbHZlKGtleXMsIG9wdCA9IHt9KSB7XG4gICAgbGV0IGZvdW5kO1xuICAgIGxldCB1c2VkS2V5O1xuICAgIGxldCBleGFjdFVzZWRLZXk7XG4gICAgbGV0IHVzZWRMbmc7XG4gICAgbGV0IHVzZWROUztcbiAgICBpZiAoaXNTdHJpbmcoa2V5cykpIGtleXMgPSBba2V5c107XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHRoaXMuZXh0cmFjdEZyb21LZXkoaywgb3B0KTtcbiAgICAgIGNvbnN0IGtleSA9IGV4dHJhY3RlZC5rZXk7XG4gICAgICB1c2VkS2V5ID0ga2V5O1xuICAgICAgbGV0IG5hbWVzcGFjZXMgPSBleHRyYWN0ZWQubmFtZXNwYWNlcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tOUykgbmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMuY29uY2F0KHRoaXMub3B0aW9ucy5mYWxsYmFja05TKTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHQuY291bnQgIT09IHVuZGVmaW5lZCAmJiAhaXNTdHJpbmcob3B0LmNvdW50KTtcbiAgICAgIGNvbnN0IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgJiYgIW9wdC5vcmRpbmFsICYmIG9wdC5jb3VudCA9PT0gMDtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0LmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiAoaXNTdHJpbmcob3B0LmNvbnRleHQpIHx8IHR5cGVvZiBvcHQuY29udGV4dCA9PT0gJ251bWJlcicpICYmIG9wdC5jb250ZXh0ICE9PSAnJztcbiAgICAgIGNvbnN0IGNvZGVzID0gb3B0LmxuZ3MgPyBvcHQubG5ncyA6IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0LmxuZyB8fCB0aGlzLmxhbmd1YWdlLCBvcHQuZmFsbGJhY2tMbmcpO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgdXNlZE5TID0gbnM7XG4gICAgICAgIGlmICghY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSAmJiB0aGlzLnV0aWxzPy5oYXNMb2FkZWROYW1lc3BhY2UgJiYgIXRoaXMudXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSh1c2VkTlMpKSB7XG4gICAgICAgICAgY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2Fybihga2V5IFwiJHt1c2VkS2V5fVwiIGZvciBsYW5ndWFnZXMgXCIke2NvZGVzLmpvaW4oJywgJyl9XCIgd29uJ3QgZ2V0IHJlc29sdmVkIGFzIG5hbWVzcGFjZSBcIiR7dXNlZE5TfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgICAgdXNlZExuZyA9IGNvZGU7XG4gICAgICAgICAgY29uc3QgZmluYWxLZXlzID0gW2tleV07XG4gICAgICAgICAgaWYgKHRoaXMuaTE4bkZvcm1hdD8uYWRkTG9va3VwS2V5cykge1xuICAgICAgICAgICAgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMoZmluYWxLZXlzLCBrZXksIGNvZGUsIG5zLCBvcHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGNvZGUsIG9wdC5jb3VudCwgb3B0KTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9TdWZmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gO1xuICAgICAgICAgICAgY29uc3Qgb3JkaW5hbFByZWZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9b3JkaW5hbCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1gO1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgaWYgKG9wdC5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtrZXl9JHt0aGlzLm9wdGlvbnMuY29udGV4dFNlcGFyYXRvcn0ke29wdC5jb250ZXh0fWA7XG4gICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkpO1xuICAgICAgICAgICAgICBpZiAobmVlZHNQbHVyYWxIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGNvbnRleHRLZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzWmVyb1N1ZmZpeExvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHplcm9TdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcG9zc2libGVLZXk7XG4gICAgICAgICAgd2hpbGUgKHBvc3NpYmxlS2V5ID0gZmluYWxLZXlzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHtcbiAgICAgICAgICAgICAgZXhhY3RVc2VkS2V5ID0gcG9zc2libGVLZXk7XG4gICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5nZXRSZXNvdXJjZShjb2RlLCBucywgcG9zc2libGVLZXksIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXM6IGZvdW5kLFxuICAgICAgdXNlZEtleSxcbiAgICAgIGV4YWN0VXNlZEtleSxcbiAgICAgIHVzZWRMbmcsXG4gICAgICB1c2VkTlNcbiAgICB9O1xuICB9XG4gIGlzVmFsaWRMb29rdXAocmVzKSB7XG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5OdWxsICYmIHJlcyA9PT0gbnVsbCkgJiYgISghdGhpcy5vcHRpb25zLnJldHVybkVtcHR5U3RyaW5nICYmIHJlcyA9PT0gJycpO1xuICB9XG4gIGdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQ/LmdldFJlc291cmNlKSByZXR1cm4gdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlU3RvcmUuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9uc0tleXMgPSBbJ2RlZmF1bHRWYWx1ZScsICdvcmRpbmFsJywgJ2NvbnRleHQnLCAncmVwbGFjZScsICdsbmcnLCAnbG5ncycsICdmYWxsYmFja0xuZycsICducycsICdrZXlTZXBhcmF0b3InLCAnbnNTZXBhcmF0b3InLCAncmV0dXJuT2JqZWN0cycsICdyZXR1cm5EZXRhaWxzJywgJ2pvaW5BcnJheXMnLCAncG9zdFByb2Nlc3MnLCAnaW50ZXJwb2xhdGlvbiddO1xuICAgIGNvbnN0IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcob3B0aW9ucy5yZXBsYWNlKTtcbiAgICBsZXQgZGF0YSA9IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgaWYgKHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcykge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzdGF0aWMgaGFzRGVmYXVsdFZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnZGVmYXVsdFZhbHVlJztcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikgJiYgcHJlZml4ID09PSBvcHRpb24uc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpICYmIHVuZGVmaW5lZCAhPT0gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY2xhc3MgTGFuZ3VhZ2VVdGlsIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdXBwb3J0ZWRMbmdzID0gdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnbGFuZ3VhZ2VVdGlscycpO1xuICB9XG4gIGdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSB7XG4gICAgY29kZSA9IGdldENsZWFuZWRDb2RlKGNvZGUpO1xuICAgIGlmICghY29kZSB8fCBjb2RlLmluZGV4T2YoJy0nKSA8IDApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHAgPSBjb2RlLnNwbGl0KCctJyk7XG4gICAgaWYgKHAubGVuZ3RoID09PSAyKSByZXR1cm4gbnVsbDtcbiAgICBwLnBvcCgpO1xuICAgIGlmIChwW3AubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocC5qb2luKCctJykpO1xuICB9XG4gIGdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIGNvZGU7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocFswXSk7XG4gIH1cbiAgZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpIHtcbiAgICBpZiAoaXNTdHJpbmcoY29kZSkgJiYgY29kZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgbGV0IGZvcm1hdHRlZENvZGU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3JtYXR0ZWRDb2RlID0gSW50bC5nZXRDYW5vbmljYWxMb2NhbGVzKGNvZGUpWzBdO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIGlmIChmb3JtYXR0ZWRDb2RlICYmIHRoaXMub3B0aW9ucy5sb3dlckNhc2VMbmcpIHtcbiAgICAgICAgZm9ybWF0dGVkQ29kZSA9IGZvcm1hdHRlZENvZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXR0ZWRDb2RlKSByZXR1cm4gZm9ybWF0dGVkQ29kZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHJldHVybiBjb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGVhbkNvZGUgfHwgdGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZyA/IGNvZGUudG9Mb3dlckNhc2UoKSA6IGNvZGU7XG4gIH1cbiAgaXNTdXBwb3J0ZWRDb2RlKGNvZGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgPT09ICdsYW5ndWFnZU9ubHknIHx8IHRoaXMub3B0aW9ucy5ub25FeHBsaWNpdFN1cHBvcnRlZExuZ3MpIHtcbiAgICAgIGNvZGUgPSB0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuc3VwcG9ydGVkTG5ncyB8fCAhdGhpcy5zdXBwb3J0ZWRMbmdzLmxlbmd0aCB8fCB0aGlzLnN1cHBvcnRlZExuZ3MuaW5kZXhPZihjb2RlKSA+IC0xO1xuICB9XG4gIGdldEJlc3RNYXRjaEZyb21Db2Rlcyhjb2Rlcykge1xuICAgIGlmICghY29kZXMpIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZDtcbiAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICBjb25zdCBjbGVhbmVkTG5nID0gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzIHx8IHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGNsZWFuZWRMbmcpKSBmb3VuZCA9IGNsZWFuZWRMbmc7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZCAmJiB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ1NjT25seSA9IHRoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpO1xuICAgICAgICBpZiAodGhpcy5pc1N1cHBvcnRlZENvZGUobG5nU2NPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nU2NPbmx5O1xuICAgICAgICBjb25zdCBsbmdPbmx5ID0gdGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGxuZ09ubHkpKSByZXR1cm4gZm91bmQgPSBsbmdPbmx5O1xuICAgICAgICBmb3VuZCA9IHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmZpbmQoc3VwcG9ydGVkTG5nID0+IHtcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nID09PSBsbmdPbmx5KSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZignLScpIDwgMCAmJiBsbmdPbmx5LmluZGV4T2YoJy0nKSA8IDApIHJldHVybjtcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA+IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwICYmIHN1cHBvcnRlZExuZy5zdWJzdHJpbmcoMCwgc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSkgPT09IGxuZ09ubHkpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKGxuZ09ubHkpID09PSAwICYmIGxuZ09ubHkubGVuZ3RoID4gMSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSB0aGlzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nKVswXTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgZ2V0RmFsbGJhY2tDb2RlcyhmYWxsYmFja3MsIGNvZGUpIHtcbiAgICBpZiAoIWZhbGxiYWNrcykgcmV0dXJuIFtdO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2tzID09PSAnZnVuY3Rpb24nKSBmYWxsYmFja3MgPSBmYWxsYmFja3MoY29kZSk7XG4gICAgaWYgKGlzU3RyaW5nKGZhbGxiYWNrcykpIGZhbGxiYWNrcyA9IFtmYWxsYmFja3NdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZhbGxiYWNrcykpIHJldHVybiBmYWxsYmFja3M7XG4gICAgaWYgKCFjb2RlKSByZXR1cm4gZmFsbGJhY2tzLmRlZmF1bHQgfHwgW107XG4gICAgbGV0IGZvdW5kID0gZmFsbGJhY2tzW2NvZGVdO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3MuZGVmYXVsdDtcbiAgICByZXR1cm4gZm91bmQgfHwgW107XG4gIH1cbiAgdG9SZXNvbHZlSGllcmFyY2h5KGNvZGUsIGZhbGxiYWNrQ29kZSkge1xuICAgIGNvbnN0IGZhbGxiYWNrQ29kZXMgPSB0aGlzLmdldEZhbGxiYWNrQ29kZXMoKGZhbGxiYWNrQ29kZSA9PT0gZmFsc2UgPyBbXSA6IGZhbGxiYWNrQ29kZSkgfHwgdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIHx8IFtdLCBjb2RlKTtcbiAgICBjb25zdCBjb2RlcyA9IFtdO1xuICAgIGNvbnN0IGFkZENvZGUgPSBjID0+IHtcbiAgICAgIGlmICghYykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGMpKSB7XG4gICAgICAgIGNvZGVzLnB1c2goYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGByZWplY3RpbmcgbGFuZ3VhZ2UgY29kZSBub3QgZm91bmQgaW4gc3VwcG9ydGVkTG5nczogJHtjfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzU3RyaW5nKGNvZGUpICYmIChjb2RlLmluZGV4T2YoJy0nKSA+IC0xIHx8IGNvZGUuaW5kZXhPZignXycpID4gLTEpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknKSBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScgJiYgdGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29kZSkpIHtcbiAgICAgIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgIH1cbiAgICBmYWxsYmFja0NvZGVzLmZvckVhY2goZmMgPT4ge1xuICAgICAgaWYgKGNvZGVzLmluZGV4T2YoZmMpIDwgMCkgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShmYykpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2RlcztcbiAgfVxufVxuXG5jb25zdCBzdWZmaXhlc09yZGVyID0ge1xuICB6ZXJvOiAwLFxuICBvbmU6IDEsXG4gIHR3bzogMixcbiAgZmV3OiAzLFxuICBtYW55OiA0LFxuICBvdGhlcjogNVxufTtcbmNvbnN0IGR1bW15UnVsZSA9IHtcbiAgc2VsZWN0OiBjb3VudCA9PiBjb3VudCA9PT0gMSA/ICdvbmUnIDogJ290aGVyJyxcbiAgcmVzb2x2ZWRPcHRpb25zOiAoKSA9PiAoe1xuICAgIHBsdXJhbENhdGVnb3JpZXM6IFsnb25lJywgJ290aGVyJ11cbiAgfSlcbn07XG5jbGFzcyBQbHVyYWxSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlVXRpbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IGxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdwbHVyYWxSZXNvbHZlcicpO1xuICAgIHRoaXMucGx1cmFsUnVsZXNDYWNoZSA9IHt9O1xuICB9XG4gIGFkZFJ1bGUobG5nLCBvYmopIHtcbiAgICB0aGlzLnJ1bGVzW2xuZ10gPSBvYmo7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGUgPSB7fTtcbiAgfVxuICBnZXRSdWxlKGNvZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNsZWFuZWRDb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSA9PT0gJ2RldicgPyAnZW4nIDogY29kZSk7XG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMub3JkaW5hbCA/ICdvcmRpbmFsJyA6ICdjYXJkaW5hbCc7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjbGVhbmVkQ29kZSxcbiAgICAgIHR5cGVcbiAgICB9KTtcbiAgICBpZiAoY2FjaGVLZXkgaW4gdGhpcy5wbHVyYWxSdWxlc0NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVyYWxSdWxlc0NhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgbGV0IHJ1bGU7XG4gICAgdHJ5IHtcbiAgICAgIHJ1bGUgPSBuZXcgSW50bC5QbHVyYWxSdWxlcyhjbGVhbmVkQ29kZSwge1xuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghSW50bCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignTm8gSW50bCBzdXBwb3J0LCBwbGVhc2UgdXNlIGFuIEludGwgcG9seWZpbGwhJyk7XG4gICAgICAgIHJldHVybiBkdW1teVJ1bGU7XG4gICAgICB9XG4gICAgICBpZiAoIWNvZGUubWF0Y2goLy18Xy8pKSByZXR1cm4gZHVtbXlSdWxlO1xuICAgICAgY29uc3QgbG5nUGFydCA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICAgIHJ1bGUgPSB0aGlzLmdldFJ1bGUobG5nUGFydCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMucGx1cmFsUnVsZXNDYWNoZVtjYWNoZUtleV0gPSBydWxlO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIG5lZWRzUGx1cmFsKGNvZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcnVsZSA9IHRoaXMuZ2V0UnVsZSgnZGV2Jywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJ1bGU/LnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMubGVuZ3RoID4gMTtcbiAgfVxuICBnZXRQbHVyYWxGb3Jtc09mS2V5KGNvZGUsIGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4ZXMoY29kZSwgb3B0aW9ucykubWFwKHN1ZmZpeCA9PiBgJHtrZXl9JHtzdWZmaXh9YCk7XG4gIH1cbiAgZ2V0U3VmZml4ZXMoY29kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSBydWxlID0gdGhpcy5nZXRSdWxlKCdkZXYnLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBbXTtcbiAgICByZXR1cm4gcnVsZS5yZXNvbHZlZE9wdGlvbnMoKS5wbHVyYWxDYXRlZ29yaWVzLnNvcnQoKHBsdXJhbENhdGVnb3J5MSwgcGx1cmFsQ2F0ZWdvcnkyKSA9PiBzdWZmaXhlc09yZGVyW3BsdXJhbENhdGVnb3J5MV0gLSBzdWZmaXhlc09yZGVyW3BsdXJhbENhdGVnb3J5Ml0pLm1hcChwbHVyYWxDYXRlZ29yeSA9PiBgJHt0aGlzLm9wdGlvbnMucHJlcGVuZH0ke29wdGlvbnMub3JkaW5hbCA/IGBvcmRpbmFsJHt0aGlzLm9wdGlvbnMucHJlcGVuZH1gIDogJyd9JHtwbHVyYWxDYXRlZ29yeX1gKTtcbiAgfVxuICBnZXRTdWZmaXgoY29kZSwgY291bnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMucHJlcGVuZH0ke29wdGlvbnMub3JkaW5hbCA/IGBvcmRpbmFsJHt0aGlzLm9wdGlvbnMucHJlcGVuZH1gIDogJyd9JHtydWxlLnNlbGVjdChjb3VudCl9YDtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2Fybihgbm8gcGx1cmFsIHJ1bGUgZm91bmQgZm9yOiAke2NvZGV9YCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4KCdkZXYnLCBjb3VudCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuY29uc3QgZGVlcEZpbmRXaXRoRGVmYXVsdHMgPSAoZGF0YSwgZGVmYXVsdERhdGEsIGtleSwga2V5U2VwYXJhdG9yID0gJy4nLCBpZ25vcmVKU09OU3RydWN0dXJlID0gdHJ1ZSkgPT4ge1xuICBsZXQgcGF0aCA9IGdldFBhdGhXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSk7XG4gIGlmICghcGF0aCAmJiBpZ25vcmVKU09OU3RydWN0dXJlICYmIGlzU3RyaW5nKGtleSkpIHtcbiAgICBwYXRoID0gZGVlcEZpbmQoZGF0YSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHBhdGggPSBkZWVwRmluZChkZWZhdWx0RGF0YSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbmNvbnN0IHJlZ2V4U2FmZSA9IHZhbCA9PiB2YWwucmVwbGFjZSgvXFwkL2csICckJCQkJyk7XG5jbGFzcyBJbnRlcnBvbGF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdpbnRlcnBvbGF0b3InKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucz8uaW50ZXJwb2xhdGlvbj8uZm9ybWF0IHx8ICh2YWx1ZSA9PiB2YWx1ZSk7XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9XG4gIGluaXQob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFvcHRpb25zLmludGVycG9sYXRpb24pIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgIGVzY2FwZVZhbHVlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBlc2NhcGU6IGVzY2FwZSQxLFxuICAgICAgZXNjYXBlVmFsdWUsXG4gICAgICB1c2VSYXdWYWx1ZVRvRXNjYXBlLFxuICAgICAgcHJlZml4LFxuICAgICAgcHJlZml4RXNjYXBlZCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHN1ZmZpeEVzY2FwZWQsXG4gICAgICBmb3JtYXRTZXBhcmF0b3IsXG4gICAgICB1bmVzY2FwZVN1ZmZpeCxcbiAgICAgIHVuZXNjYXBlUHJlZml4LFxuICAgICAgbmVzdGluZ1ByZWZpeCxcbiAgICAgIG5lc3RpbmdQcmVmaXhFc2NhcGVkLFxuICAgICAgbmVzdGluZ1N1ZmZpeCxcbiAgICAgIG5lc3RpbmdTdWZmaXhFc2NhcGVkLFxuICAgICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3IsXG4gICAgICBtYXhSZXBsYWNlcyxcbiAgICAgIGFsd2F5c0Zvcm1hdFxuICAgIH0gPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5lc2NhcGUgPSBlc2NhcGUkMSAhPT0gdW5kZWZpbmVkID8gZXNjYXBlJDEgOiBlc2NhcGU7XG4gICAgdGhpcy5lc2NhcGVWYWx1ZSA9IGVzY2FwZVZhbHVlICE9PSB1bmRlZmluZWQgPyBlc2NhcGVWYWx1ZSA6IHRydWU7XG4gICAgdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlID0gdXNlUmF3VmFsdWVUb0VzY2FwZSAhPT0gdW5kZWZpbmVkID8gdXNlUmF3VmFsdWVUb0VzY2FwZSA6IGZhbHNlO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4ID8gcmVnZXhFc2NhcGUocHJlZml4KSA6IHByZWZpeEVzY2FwZWQgfHwgJ3t7JztcbiAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeCA/IHJlZ2V4RXNjYXBlKHN1ZmZpeCkgOiBzdWZmaXhFc2NhcGVkIHx8ICd9fSc7XG4gICAgdGhpcy5mb3JtYXRTZXBhcmF0b3IgPSBmb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMudW5lc2NhcGVQcmVmaXggPSB1bmVzY2FwZVN1ZmZpeCA/ICcnIDogdW5lc2NhcGVQcmVmaXggfHwgJy0nO1xuICAgIHRoaXMudW5lc2NhcGVTdWZmaXggPSB0aGlzLnVuZXNjYXBlUHJlZml4ID8gJycgOiB1bmVzY2FwZVN1ZmZpeCB8fCAnJztcbiAgICB0aGlzLm5lc3RpbmdQcmVmaXggPSBuZXN0aW5nUHJlZml4ID8gcmVnZXhFc2NhcGUobmVzdGluZ1ByZWZpeCkgOiBuZXN0aW5nUHJlZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnJHQoJyk7XG4gICAgdGhpcy5uZXN0aW5nU3VmZml4ID0gbmVzdGluZ1N1ZmZpeCA/IHJlZ2V4RXNjYXBlKG5lc3RpbmdTdWZmaXgpIDogbmVzdGluZ1N1ZmZpeEVzY2FwZWQgfHwgcmVnZXhFc2NhcGUoJyknKTtcbiAgICB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yID0gbmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMubWF4UmVwbGFjZXMgPSBtYXhSZXBsYWNlcyB8fCAxMDAwO1xuICAgIHRoaXMuYWx3YXlzRm9ybWF0ID0gYWx3YXlzRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBhbHdheXNGb3JtYXQgOiBmYWxzZTtcbiAgICB0aGlzLnJlc2V0UmVnRXhwKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucykgdGhpcy5pbml0KHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgcmVzZXRSZWdFeHAoKSB7XG4gICAgY29uc3QgZ2V0T3JSZXNldFJlZ0V4cCA9IChleGlzdGluZ1JlZ0V4cCwgcGF0dGVybikgPT4ge1xuICAgICAgaWYgKGV4aXN0aW5nUmVnRXhwPy5zb3VyY2UgPT09IHBhdHRlcm4pIHtcbiAgICAgICAgZXhpc3RpbmdSZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUmVnRXhwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKTtcbiAgICB9O1xuICAgIHRoaXMucmVnZXhwID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLnJlZ2V4cCwgYCR7dGhpcy5wcmVmaXh9KC4rPykke3RoaXMuc3VmZml4fWApO1xuICAgIHRoaXMucmVnZXhwVW5lc2NhcGUgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMucmVnZXhwVW5lc2NhcGUsIGAke3RoaXMucHJlZml4fSR7dGhpcy51bmVzY2FwZVByZWZpeH0oLis/KSR7dGhpcy51bmVzY2FwZVN1ZmZpeH0ke3RoaXMuc3VmZml4fWApO1xuICAgIHRoaXMubmVzdGluZ1JlZ2V4cCA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5uZXN0aW5nUmVnZXhwLCBgJHt0aGlzLm5lc3RpbmdQcmVmaXh9KC4rPykke3RoaXMubmVzdGluZ1N1ZmZpeH1gKTtcbiAgfVxuICBpbnRlcnBvbGF0ZShzdHIsIGRhdGEsIGxuZywgb3B0aW9ucykge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IHJlcGxhY2VzO1xuICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMgfHwge307XG4gICAgY29uc3QgaGFuZGxlRm9ybWF0ID0ga2V5ID0+IHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5LCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsd2F5c0Zvcm1hdCA/IHRoaXMuZm9ybWF0KHBhdGgsIHVuZGVmaW5lZCwgbG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IGtleVxuICAgICAgICB9KSA6IHBhdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBwID0ga2V5LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgIGNvbnN0IGsgPSBwLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgY29uc3QgZiA9IHAuam9pbih0aGlzLmZvcm1hdFNlcGFyYXRvcikudHJpbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrLCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yLCB0aGlzLm9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSksIGYsIGxuZywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgICBjb25zdCBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgPSBvcHRpb25zPy5taXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgfHwgdGhpcy5vcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjtcbiAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBvcHRpb25zPy5pbnRlcnBvbGF0aW9uPy5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXM7XG4gICAgY29uc3QgdG9kb3MgPSBbe1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwVW5lc2NhcGUsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiByZWdleFNhZmUodmFsKVxuICAgIH0sIHtcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cCxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsKSkgOiByZWdleFNhZmUodmFsKVxuICAgIH1dO1xuICAgIHRvZG9zLmZvckVhY2godG9kbyA9PiB7XG4gICAgICByZXBsYWNlcyA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggPSB0b2RvLnJlZ2V4LmV4ZWMoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkVmFyID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaGVkVmFyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcihzdHIsIG1hdGNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlID0gaXNTdHJpbmcodGVtcCkgPyB0ZW1wIDogJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBtYXRjaGVkVmFyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcGFzcyBpbiB2YXJpYWJsZSAke21hdGNoZWRWYXJ9IGZvciBpbnRlcnBvbGF0aW5nICR7c3RyfWApO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKHZhbHVlKSAmJiAhdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlVmFsdWUgPSB0b2RvLnNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCBzYWZlVmFsdWUpO1xuICAgICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZXMrKztcbiAgICAgICAgaWYgKHJlcGxhY2VzID49IHRoaXMubWF4UmVwbGFjZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbmVzdChzdHIsIGZjLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBjbG9uZWRPcHRpb25zO1xuICAgIGNvbnN0IGhhbmRsZUhhc09wdGlvbnMgPSAoa2V5LCBpbmhlcml0ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzZXAgPSB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yO1xuICAgICAgaWYgKGtleS5pbmRleE9mKHNlcCkgPCAwKSByZXR1cm4ga2V5O1xuICAgICAgY29uc3QgYyA9IGtleS5zcGxpdChuZXcgUmVnRXhwKGAke3NlcH1bIF0qe2ApKTtcbiAgICAgIGxldCBvcHRpb25zU3RyaW5nID0gYHske2NbMV19YDtcbiAgICAgIGtleSA9IGNbMF07XG4gICAgICBvcHRpb25zU3RyaW5nID0gdGhpcy5pbnRlcnBvbGF0ZShvcHRpb25zU3RyaW5nLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1hdGNoZWRTaW5nbGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC8nL2cpO1xuICAgICAgY29uc3QgbWF0Y2hlZERvdWJsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goL1wiL2cpO1xuICAgICAgaWYgKChtYXRjaGVkU2luZ2xlUXVvdGVzPy5sZW5ndGggPz8gMCkgJSAyID09PSAwICYmICFtYXRjaGVkRG91YmxlUXVvdGVzIHx8IG1hdGNoZWREb3VibGVRdW90ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBvcHRpb25zU3RyaW5nID0gb3B0aW9uc1N0cmluZy5yZXBsYWNlKC8nL2csICdcIicpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xvbmVkT3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9uc1N0cmluZyk7XG4gICAgICAgIGlmIChpbmhlcml0ZWRPcHRpb25zKSBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAgIC4uLmluaGVyaXRlZE9wdGlvbnMsXG4gICAgICAgICAgLi4uY2xvbmVkT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBmYWlsZWQgcGFyc2luZyBvcHRpb25zIHN0cmluZyBpbiBuZXN0aW5nIGZvciBrZXkgJHtrZXl9YCwgZSk7XG4gICAgICAgIHJldHVybiBgJHtrZXl9JHtzZXB9JHtvcHRpb25zU3RyaW5nfWA7XG4gICAgICB9XG4gICAgICBpZiAoY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUgJiYgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUuaW5kZXhPZih0aGlzLnByZWZpeCkgPiAtMSkgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcoY2xvbmVkT3B0aW9ucy5yZXBsYWNlKSA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgY29uc3Qga2V5RW5kSW5kZXggPSAvey4qfS8udGVzdChtYXRjaFsxXSkgPyBtYXRjaFsxXS5sYXN0SW5kZXhPZignfScpICsgMSA6IG1hdGNoWzFdLmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgICAgaWYgKGtleUVuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBmb3JtYXR0ZXJzID0gbWF0Y2hbMV0uc2xpY2Uoa2V5RW5kSW5kZXgpLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnNsaWNlKDAsIGtleUVuZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gZmMoaGFuZGxlSGFzT3B0aW9ucy5jYWxsKHRoaXMsIG1hdGNoWzFdLnRyaW0oKSwgY2xvbmVkT3B0aW9ucyksIGNsb25lZE9wdGlvbnMpO1xuICAgICAgaWYgKHZhbHVlICYmIG1hdGNoWzBdID09PSBzdHIgJiYgIWlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byByZXNvbHZlICR7bWF0Y2hbMV19IGZvciBuZXN0aW5nICR7c3RyfWApO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVycy5yZWR1Y2UoKHYsIGYpID0+IHRoaXMuZm9ybWF0KHYsIGYsIG9wdGlvbnMubG5nLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBtYXRjaFsxXS50cmltKClcbiAgICAgICAgfSksIHZhbHVlLnRyaW0oKSk7XG4gICAgICB9XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgdmFsdWUpO1xuICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5jb25zdCBwYXJzZUZvcm1hdFN0ciA9IGZvcm1hdFN0ciA9PiB7XG4gIGxldCBmb3JtYXROYW1lID0gZm9ybWF0U3RyLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBjb25zdCBmb3JtYXRPcHRpb25zID0ge307XG4gIGlmIChmb3JtYXRTdHIuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICBjb25zdCBwID0gZm9ybWF0U3RyLnNwbGl0KCcoJyk7XG4gICAgZm9ybWF0TmFtZSA9IHBbMF0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc3Qgb3B0U3RyID0gcFsxXS5zdWJzdHJpbmcoMCwgcFsxXS5sZW5ndGggLSAxKTtcbiAgICBpZiAoZm9ybWF0TmFtZSA9PT0gJ2N1cnJlbmN5JyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLmN1cnJlbmN5KSBmb3JtYXRPcHRpb25zLmN1cnJlbmN5ID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE5hbWUgPT09ICdyZWxhdGl2ZXRpbWUnICYmIG9wdFN0ci5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMucmFuZ2UpIGZvcm1hdE9wdGlvbnMucmFuZ2UgPSBvcHRTdHIudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRzID0gb3B0U3RyLnNwbGl0KCc7Jyk7XG4gICAgICBvcHRzLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gb3B0LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgY29uc3QgdmFsID0gcmVzdC5qb2luKCc6JykudHJpbSgpLnJlcGxhY2UoL14nK3wnKyQvZywgJycpO1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRLZXkgPSBrZXkudHJpbSgpO1xuICAgICAgICAgIGlmICghZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSkgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAnZmFsc2UnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gJ3RydWUnKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbCkpIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZm9ybWF0TmFtZSxcbiAgICBmb3JtYXRPcHRpb25zXG4gIH07XG59O1xuY29uc3QgY3JlYXRlQ2FjaGVkRm9ybWF0dGVyID0gZm4gPT4ge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuICByZXR1cm4gKHYsIGwsIG8pID0+IHtcbiAgICBsZXQgb3B0Rm9yQ2FjaGUgPSBvO1xuICAgIGlmIChvICYmIG8uaW50ZXJwb2xhdGlvbmtleSAmJiBvLmZvcm1hdFBhcmFtcyAmJiBvLmZvcm1hdFBhcmFtc1tvLmludGVycG9sYXRpb25rZXldICYmIG9bby5pbnRlcnBvbGF0aW9ua2V5XSkge1xuICAgICAgb3B0Rm9yQ2FjaGUgPSB7XG4gICAgICAgIC4uLm9wdEZvckNhY2hlLFxuICAgICAgICBbby5pbnRlcnBvbGF0aW9ua2V5XTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBsICsgSlNPTi5zdHJpbmdpZnkob3B0Rm9yQ2FjaGUpO1xuICAgIGxldCBmcm0gPSBjYWNoZVtrZXldO1xuICAgIGlmICghZnJtKSB7XG4gICAgICBmcm0gPSBmbihnZXRDbGVhbmVkQ29kZShsKSwgbyk7XG4gICAgICBjYWNoZVtrZXldID0gZnJtO1xuICAgIH1cbiAgICByZXR1cm4gZnJtKHYpO1xuICB9O1xufTtcbmNvbnN0IGNyZWF0ZU5vbkNhY2hlZEZvcm1hdHRlciA9IGZuID0+ICh2LCBsLCBvKSA9PiBmbihnZXRDbGVhbmVkQ29kZShsKSwgbykodik7XG5jbGFzcyBGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdmb3JtYXR0ZXInKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KHNlcnZpY2VzLCBvcHRpb25zID0ge1xuICAgIGludGVycG9sYXRpb246IHt9XG4gIH0pIHtcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICAgIGNvbnN0IGNmID0gb3B0aW9ucy5jYWNoZUluQnVpbHRGb3JtYXRzID8gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyIDogY3JlYXRlTm9uQ2FjaGVkRm9ybWF0dGVyO1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG51bWJlcjogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBjdXJyZW5jeTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBkYXRldGltZTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIHJlbGF0aXZldGltZTogY2YoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwsIG9wdC5yYW5nZSB8fCAnZGF5Jyk7XG4gICAgICB9KSxcbiAgICAgIGxpc3Q6IGNmKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgYWRkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gZmM7XG4gIH1cbiAgYWRkQ2FjaGVkKG5hbWUsIGZjKSB7XG4gICAgdGhpcy5mb3JtYXRzW25hbWUudG9Mb3dlckNhc2UoKS50cmltKCldID0gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKGZjKTtcbiAgfVxuICBmb3JtYXQodmFsdWUsIGZvcm1hdCwgbG5nLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBpZiAoZm9ybWF0cy5sZW5ndGggPiAxICYmIGZvcm1hdHNbMF0uaW5kZXhPZignKCcpID4gMSAmJiBmb3JtYXRzWzBdLmluZGV4T2YoJyknKSA8IDAgJiYgZm9ybWF0cy5maW5kKGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcm1hdHMuZmluZEluZGV4KGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSk7XG4gICAgICBmb3JtYXRzWzBdID0gW2Zvcm1hdHNbMF0sIC4uLmZvcm1hdHMuc3BsaWNlKDEsIGxhc3RJbmRleCldLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucz8uZm9ybWF0UGFyYW1zPy5bb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBsID0gdmFsT3B0aW9ucy5sb2NhbGUgfHwgdmFsT3B0aW9ucy5sbmcgfHwgb3B0aW9ucy5sb2NhbGUgfHwgb3B0aW9ucy5sbmcgfHwgbG5nO1xuICAgICAgICAgIGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0c1tmb3JtYXROYW1lXShtZW0sIGwsIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgLi4udmFsT3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGB0aGVyZSB3YXMgbm8gZm9ybWF0IGZ1bmN0aW9uIGZvciAke2Zvcm1hdE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtO1xuICAgIH0sIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmNvbnN0IHJlbW92ZVBlbmRpbmcgPSAocSwgbmFtZSkgPT4ge1xuICBpZiAocS5wZW5kaW5nW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgcS5wZW5kaW5nW25hbWVdO1xuICAgIHEucGVuZGluZ0NvdW50LS07XG4gIH1cbn07XG5jbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihiYWNrZW5kLCBzdG9yZSwgc2VydmljZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IHNlcnZpY2VzLmxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdiYWNrZW5kQ29ubmVjdG9yJyk7XG4gICAgdGhpcy53YWl0aW5nUmVhZHMgPSBbXTtcbiAgICB0aGlzLm1heFBhcmFsbGVsUmVhZHMgPSBvcHRpb25zLm1heFBhcmFsbGVsUmVhZHMgfHwgMTA7XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMgPSAwO1xuICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA+PSAwID8gb3B0aW9ucy5tYXhSZXRyaWVzIDogNTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IG9wdGlvbnMucmV0cnlUaW1lb3V0ID49IDEgPyBvcHRpb25zLnJldHJ5VGltZW91dCA6IDM1MDtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMuYmFja2VuZD8uaW5pdD8uKHNlcnZpY2VzLCBvcHRpb25zLmJhY2tlbmQsIG9wdGlvbnMpO1xuICB9XG4gIHF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdG9Mb2FkID0ge307XG4gICAgY29uc3QgcGVuZGluZyA9IHt9O1xuICAgIGNvbnN0IHRvTG9hZExhbmd1YWdlcyA9IHt9O1xuICAgIGNvbnN0IHRvTG9hZE5hbWVzcGFjZXMgPSB7fTtcbiAgICBsYW5ndWFnZXMuZm9yRWFjaChsbmcgPT4ge1xuICAgICAgbGV0IGhhc0FsbE5hbWVzcGFjZXMgPSB0cnVlO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke2xuZ318JHtuc31gO1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVsb2FkICYmIHRoaXMuc3RvcmUuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlW25hbWVdIDwgMCkgOyBlbHNlIGlmICh0aGlzLnN0YXRlW25hbWVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IDE7XG4gICAgICAgICAgaGFzQWxsTmFtZXNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChwZW5kaW5nW25hbWVdID09PSB1bmRlZmluZWQpIHBlbmRpbmdbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWRbbmFtZV0gPT09IHVuZGVmaW5lZCkgdG9Mb2FkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodG9Mb2FkTmFtZXNwYWNlc1tuc10gPT09IHVuZGVmaW5lZCkgdG9Mb2FkTmFtZXNwYWNlc1tuc10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzQWxsTmFtZXNwYWNlcykgdG9Mb2FkTGFuZ3VhZ2VzW2xuZ10gPSB0cnVlO1xuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh0b0xvYWQpLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7XG4gICAgICAgIHBlbmRpbmcsXG4gICAgICAgIHBlbmRpbmdDb3VudDogT2JqZWN0LmtleXMocGVuZGluZykubGVuZ3RoLFxuICAgICAgICBsb2FkZWQ6IHt9LFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b0xvYWQ6IE9iamVjdC5rZXlzKHRvTG9hZCksXG4gICAgICBwZW5kaW5nOiBPYmplY3Qua2V5cyhwZW5kaW5nKSxcbiAgICAgIHRvTG9hZExhbmd1YWdlczogT2JqZWN0LmtleXModG9Mb2FkTGFuZ3VhZ2VzKSxcbiAgICAgIHRvTG9hZE5hbWVzcGFjZXM6IE9iamVjdC5rZXlzKHRvTG9hZE5hbWVzcGFjZXMpXG4gICAgfTtcbiAgfVxuICBsb2FkZWQobmFtZSwgZXJyLCBkYXRhKSB7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2ZhaWxlZExvYWRpbmcnLCBsbmcsIG5zLCBlcnIpO1xuICAgIGlmICghZXJyICYmIGRhdGEpIHtcbiAgICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgc2tpcENvcHk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlW25hbWVdID0gZXJyID8gLTEgOiAyO1xuICAgIGlmIChlcnIgJiYgZGF0YSkgdGhpcy5zdGF0ZVtuYW1lXSA9IDA7XG4gICAgY29uc3QgbG9hZGVkID0ge307XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHEgPT4ge1xuICAgICAgcHVzaFBhdGgocS5sb2FkZWQsIFtsbmddLCBucyk7XG4gICAgICByZW1vdmVQZW5kaW5nKHEsIG5hbWUpO1xuICAgICAgaWYgKGVycikgcS5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgaWYgKHEucGVuZGluZ0NvdW50ID09PSAwICYmICFxLmRvbmUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocS5sb2FkZWQpLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWRbbF0pIGxvYWRlZFtsXSA9IHt9O1xuICAgICAgICAgIGNvbnN0IGxvYWRlZEtleXMgPSBxLmxvYWRlZFtsXTtcbiAgICAgICAgICBpZiAobG9hZGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvYWRlZEtleXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxvYWRlZFtsXVtuXSA9PT0gdW5kZWZpbmVkKSBsb2FkZWRbbF1bbl0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcS5kb25lID0gdHJ1ZTtcbiAgICAgICAgaWYgKHEuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHEuY2FsbGJhY2socS5lcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHEuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgbG9hZGVkKTtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIocSA9PiAhcS5kb25lKTtcbiAgfVxuICByZWFkKGxuZywgbnMsIGZjTmFtZSwgdHJpZWQgPSAwLCB3YWl0ID0gdGhpcy5yZXRyeVRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFsbmcubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwge30pO1xuICAgIGlmICh0aGlzLnJlYWRpbmdDYWxscyA+PSB0aGlzLm1heFBhcmFsbGVsUmVhZHMpIHtcbiAgICAgIHRoaXMud2FpdGluZ1JlYWRzLnB1c2goe1xuICAgICAgICBsbmcsXG4gICAgICAgIG5zLFxuICAgICAgICBmY05hbWUsXG4gICAgICAgIHRyaWVkLFxuICAgICAgICB3YWl0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVhZGluZ0NhbGxzKys7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICB0aGlzLnJlYWRpbmdDYWxscy0tO1xuICAgICAgaWYgKHRoaXMud2FpdGluZ1JlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMud2FpdGluZ1JlYWRzLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucmVhZChuZXh0LmxuZywgbmV4dC5ucywgbmV4dC5mY05hbWUsIG5leHQudHJpZWQsIG5leHQud2FpdCwgbmV4dC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyICYmIGRhdGEgJiYgdHJpZWQgPCB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWFkLmNhbGwodGhpcywgbG5nLCBucywgZmNOYW1lLCB0cmllZCArIDEsIHdhaXQgKiAyLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgIH07XG4gICAgY29uc3QgZmMgPSB0aGlzLmJhY2tlbmRbZmNOYW1lXS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgaWYgKGZjLmxlbmd0aCA9PT0gMikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IGZjKGxuZywgbnMpO1xuICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgci50aGVuKGRhdGEgPT4gcmVzb2x2ZXIobnVsbCwgZGF0YSkpLmNhdGNoKHJlc29sdmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlcihudWxsLCByKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmVyKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmYyhsbmcsIG5zLCByZXNvbHZlcik7XG4gIH1cbiAgcHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGxhbmd1YWdlcykpIGxhbmd1YWdlcyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobGFuZ3VhZ2VzKTtcbiAgICBpZiAoaXNTdHJpbmcobmFtZXNwYWNlcykpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgY29uc3QgdG9Mb2FkID0gdGhpcy5xdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0b0xvYWQudG9Mb2FkLmxlbmd0aCkge1xuICAgICAgaWYgKCF0b0xvYWQucGVuZGluZy5sZW5ndGgpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Mb2FkLnRvTG9hZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdGhpcy5sb2FkT25lKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCB7fSwgY2FsbGJhY2spO1xuICB9XG4gIHJlbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHtcbiAgICAgIHJlbG9hZDogdHJ1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfVxuICBsb2FkT25lKG5hbWUsIHByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICB0aGlzLnJlYWQobG5nLCBucywgJ3JlYWQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikgdGhpcy5sb2dnZXIud2FybihgJHtwcmVmaXh9bG9hZGluZyBuYW1lc3BhY2UgJHtuc30gZm9yIGxhbmd1YWdlICR7bG5nfSBmYWlsZWRgLCBlcnIpO1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YSkgdGhpcy5sb2dnZXIubG9nKGAke3ByZWZpeH1sb2FkZWQgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ31gLCBkYXRhKTtcbiAgICAgIHRoaXMubG9hZGVkKG5hbWUsIGVyciwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgc2F2ZU1pc3NpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgaXNVcGRhdGUsIG9wdGlvbnMgPSB7fSwgY2xiID0gKCkgPT4ge30pIHtcbiAgICBpZiAodGhpcy5zZXJ2aWNlcz8udXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy5zZXJ2aWNlcz8udXRpbHM/Lmhhc0xvYWRlZE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBkaWQgbm90IHNhdmUga2V5IFwiJHtrZXl9XCIgYXMgdGhlIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCBrZXkgPT09ICcnKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYmFja2VuZD8uY3JlYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc1VwZGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kLmNyZWF0ZS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgICBpZiAoZmMubGVuZ3RoIDwgNikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByO1xuICAgICAgICAgIGlmIChmYy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByLnRoZW4oZGF0YSA9PiBjbGIobnVsbCwgZGF0YSkpLmNhdGNoKGNsYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYihudWxsLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsYihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBjbGIsIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoKSA9PiAoe1xuICBkZWJ1ZzogZmFsc2UsXG4gIGluaXRBc3luYzogdHJ1ZSxcbiAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgZGVmYXVsdE5TOiBbJ3RyYW5zbGF0aW9uJ10sXG4gIGZhbGxiYWNrTG5nOiBbJ2RldiddLFxuICBmYWxsYmFja05TOiBmYWxzZSxcbiAgc3VwcG9ydGVkTG5nczogZmFsc2UsXG4gIG5vbkV4cGxpY2l0U3VwcG9ydGVkTG5nczogZmFsc2UsXG4gIGxvYWQ6ICdhbGwnLFxuICBwcmVsb2FkOiBmYWxzZSxcbiAgc2ltcGxpZnlQbHVyYWxTdWZmaXg6IHRydWUsXG4gIGtleVNlcGFyYXRvcjogJy4nLFxuICBuc1NlcGFyYXRvcjogJzonLFxuICBwbHVyYWxTZXBhcmF0b3I6ICdfJyxcbiAgY29udGV4dFNlcGFyYXRvcjogJ18nLFxuICBwYXJ0aWFsQnVuZGxlZExhbmd1YWdlczogZmFsc2UsXG4gIHNhdmVNaXNzaW5nOiBmYWxzZSxcbiAgdXBkYXRlTWlzc2luZzogZmFsc2UsXG4gIHNhdmVNaXNzaW5nVG86ICdmYWxsYmFjaycsXG4gIHNhdmVNaXNzaW5nUGx1cmFsczogdHJ1ZSxcbiAgbWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXI6IGZhbHNlLFxuICBwb3N0UHJvY2VzczogZmFsc2UsXG4gIHBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkOiBmYWxzZSxcbiAgcmV0dXJuTnVsbDogZmFsc2UsXG4gIHJldHVybkVtcHR5U3RyaW5nOiB0cnVlLFxuICByZXR1cm5PYmplY3RzOiBmYWxzZSxcbiAgam9pbkFycmF5czogZmFsc2UsXG4gIHJldHVybmVkT2JqZWN0SGFuZGxlcjogZmFsc2UsXG4gIHBhcnNlTWlzc2luZ0tleUhhbmRsZXI6IGZhbHNlLFxuICBhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXk6IGZhbHNlLFxuICBhcHBlbmROYW1lc3BhY2VUb0NJTW9kZTogZmFsc2UsXG4gIG92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyOiBhcmdzID0+IHtcbiAgICBsZXQgcmV0ID0ge307XG4gICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0JykgcmV0ID0gYXJnc1sxXTtcbiAgICBpZiAoaXNTdHJpbmcoYXJnc1sxXSkpIHJldC5kZWZhdWx0VmFsdWUgPSBhcmdzWzFdO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzJdKSkgcmV0LnREZXNjcmlwdGlvbiA9IGFyZ3NbMl07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYXJnc1szXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzNdIHx8IGFyZ3NbMl07XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHJldFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGludGVycG9sYXRpb246IHtcbiAgICBlc2NhcGVWYWx1ZTogdHJ1ZSxcbiAgICBmb3JtYXQ6IHZhbHVlID0+IHZhbHVlLFxuICAgIHByZWZpeDogJ3t7JyxcbiAgICBzdWZmaXg6ICd9fScsXG4gICAgZm9ybWF0U2VwYXJhdG9yOiAnLCcsXG4gICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcbiAgICBuZXN0aW5nUHJlZml4OiAnJHQoJyxcbiAgICBuZXN0aW5nU3VmZml4OiAnKScsXG4gICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3I6ICcsJyxcbiAgICBtYXhSZXBsYWNlczogMTAwMCxcbiAgICBza2lwT25WYXJpYWJsZXM6IHRydWVcbiAgfSxcbiAgY2FjaGVJbkJ1aWx0Rm9ybWF0czogdHJ1ZVxufSk7XG5jb25zdCB0cmFuc2Zvcm1PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmIChpc1N0cmluZyhvcHRpb25zLm5zKSkgb3B0aW9ucy5ucyA9IFtvcHRpb25zLm5zXTtcbiAgaWYgKGlzU3RyaW5nKG9wdGlvbnMuZmFsbGJhY2tMbmcpKSBvcHRpb25zLmZhbGxiYWNrTG5nID0gW29wdGlvbnMuZmFsbGJhY2tMbmddO1xuICBpZiAoaXNTdHJpbmcob3B0aW9ucy5mYWxsYmFja05TKSkgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG4gIGlmIChvcHRpb25zLnN1cHBvcnRlZExuZ3M/LmluZGV4T2Y/LignY2ltb2RlJykgPCAwKSB7XG4gICAgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzID0gb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmNvbmNhdChbJ2NpbW9kZSddKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5pdEltbWVkaWF0ZSA9PT0gJ2Jvb2xlYW4nKSBvcHRpb25zLmluaXRBc3luYyA9IG9wdGlvbnMuaW5pdEltbWVkaWF0ZTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBiaW5kTWVtYmVyRnVuY3Rpb25zID0gaW5zdCA9PiB7XG4gIGNvbnN0IG1lbXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdCkpO1xuICBtZW1zLmZvckVhY2gobWVtID0+IHtcbiAgICBpZiAodHlwZW9mIGluc3RbbWVtXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdFttZW1dID0gaW5zdFttZW1dLmJpbmQoaW5zdCk7XG4gICAgfVxuICB9KTtcbn07XG5jbGFzcyBJMThuIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNlcnZpY2VzID0ge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgIHRoaXMubW9kdWxlcyA9IHtcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgYmluZE1lbWJlckZ1bmN0aW9ucyh0aGlzKTtcbiAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMuaXNJbml0aWFsaXplZCAmJiAhb3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbml0QXN5bmMpIHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBpbml0KG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdE5TID09IG51bGwgJiYgb3B0aW9ucy5ucykge1xuICAgICAgaWYgKGlzU3RyaW5nKG9wdGlvbnMubnMpKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ucy5pbmRleE9mKCd0cmFuc2xhdGlvbicpIDwgMCkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZk9wdHMgPSBnZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZPcHRzLFxuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4udHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICAuLi5kZWZPcHRzLmludGVycG9sYXRpb24sXG4gICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZEtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uc1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgfVxuICAgIGNvbnN0IGNyZWF0ZUNsYXNzT25EZW1hbmQgPSBDbGFzc09yT2JqZWN0ID0+IHtcbiAgICAgIGlmICghQ2xhc3NPck9iamVjdCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIENsYXNzT3JPYmplY3QgPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgQ2xhc3NPck9iamVjdCgpO1xuICAgICAgcmV0dXJuIENsYXNzT3JPYmplY3Q7XG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxvZ2dlcikge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubG9nZ2VyKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VMb2dnZXIuaW5pdChudWxsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlcjtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IHRoaXMubW9kdWxlcy5mb3JtYXR0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBsdSA9IG5ldyBMYW5ndWFnZVV0aWwodGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZSh0aGlzLm9wdGlvbnMucmVzb3VyY2VzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2VydmljZXM7XG4gICAgICBzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgICBzLnJlc291cmNlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgcy5sYW5ndWFnZVV0aWxzID0gbHU7XG4gICAgICBzLnBsdXJhbFJlc29sdmVyID0gbmV3IFBsdXJhbFJlc29sdmVyKGx1LCB7XG4gICAgICAgIHByZXBlbmQ6IHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IsXG4gICAgICAgIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0aGlzLm9wdGlvbnMuc2ltcGxpZnlQbHVyYWxTdWZmaXhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgIT09IGRlZk9wdHMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgICBpZiAodXNpbmdMZWdhY3lGb3JtYXRGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBpbml0OiB5b3UgYXJlIHN0aWxsIHVzaW5nIHRoZSBsZWdhY3kgZm9ybWF0IGZ1bmN0aW9uLCBwbGVhc2UgdXNlIHRoZSBuZXcgYXBwcm9hY2g6IGh0dHBzOi8vd3d3LmkxOG5leHQuY29tL3RyYW5zbGF0aW9uLWZ1bmN0aW9uL2Zvcm1hdHRpbmdgKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXR0ZXIgJiYgKCF0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgfHwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID09PSBkZWZPcHRzLmludGVycG9sYXRpb24uZm9ybWF0KSkge1xuICAgICAgICBzLmZvcm1hdHRlciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQoZm9ybWF0dGVyKTtcbiAgICAgICAgaWYgKHMuZm9ybWF0dGVyLmluaXQpIHMuZm9ybWF0dGVyLmluaXQocywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID0gcy5mb3JtYXR0ZXIuZm9ybWF0LmJpbmQocy5mb3JtYXR0ZXIpO1xuICAgICAgfVxuICAgICAgcy5pbnRlcnBvbGF0b3IgPSBuZXcgSW50ZXJwb2xhdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICBzLnV0aWxzID0ge1xuICAgICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IHRoaXMuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmJhY2tlbmQpLCBzLnJlc291cmNlU3RvcmUsIHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3Iub24oJyonLCAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKSB7XG4gICAgICAgIHMubGFuZ3VhZ2VEZXRlY3RvciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpO1xuICAgICAgICBpZiAocy5sYW5ndWFnZURldGVjdG9yLmluaXQpIHMubGFuZ3VhZ2VEZXRlY3Rvci5pbml0KHMsIHRoaXMub3B0aW9ucy5kZXRlY3Rpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQpIHtcbiAgICAgICAgcy5pMThuRm9ybWF0ID0gY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCk7XG4gICAgICAgIGlmIChzLmkxOG5Gb3JtYXQuaW5pdCkgcy5pMThuRm9ybWF0LmluaXQodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih0aGlzLnNlcnZpY2VzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2xhdG9yLm9uKCcqJywgKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICBpZiAobS5pbml0KSBtLmluaXQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgY29uc3QgY29kZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgaWYgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbMF0gIT09ICdkZXYnKSB0aGlzLm9wdGlvbnMubG5nID0gY29kZXNbMF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBubyBsYW5ndWFnZURldGVjdG9yIGlzIHVzZWQgYW5kIG5vIGxuZyBpcyBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlQXBpID0gWydnZXRSZXNvdXJjZScsICdoYXNSZXNvdXJjZUJ1bmRsZScsICdnZXRSZXNvdXJjZUJ1bmRsZScsICdnZXREYXRhQnlMYW5ndWFnZSddO1xuICAgIHN0b3JlQXBpLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9ICguLi5hcmdzKSA9PiB0aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJncyk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmVBcGlDaGFpbmVkID0gWydhZGRSZXNvdXJjZScsICdhZGRSZXNvdXJjZXMnLCAnYWRkUmVzb3VyY2VCdW5kbGUnLCAncmVtb3ZlUmVzb3VyY2VCdW5kbGUnXTtcbiAgICBzdG9yZUFwaUNoYWluZWQuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaW5pc2ggPSAoZXJyLCB0KSA9PiB7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCAmJiAhdGhpcy5pbml0aWFsaXplZFN0b3JlT25jZSkgdGhpcy5sb2dnZXIud2FybignaW5pdDogaTE4bmV4dCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLiBZb3Ugc2hvdWxkIGNhbGwgaW5pdCBqdXN0IG9uY2UhJyk7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzQ2xvbmUpIHRoaXMubG9nZ2VyLmxvZygnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0KTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB0KTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sYW5ndWFnZXMgJiYgIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIGZpbmlzaChudWxsLCB0aGlzLnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNoYW5nZUxhbmd1YWdlKHRoaXMub3B0aW9ucy5sbmcsIGZpbmlzaCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc291cmNlcyB8fCAhdGhpcy5vcHRpb25zLmluaXRBc3luYykge1xuICAgICAgbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGxvYWQsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZFJlc291cmNlcyhsYW5ndWFnZSwgY2FsbGJhY2sgPSBub29wKSB7XG4gICAgbGV0IHVzZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGNvbnN0IHVzZWRMbmcgPSBpc1N0cmluZyhsYW5ndWFnZSkgPyBsYW5ndWFnZSA6IHRoaXMubGFuZ3VhZ2U7XG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ2Z1bmN0aW9uJykgdXNlZENhbGxiYWNrID0gbGFuZ3VhZ2U7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8IHRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykge1xuICAgICAgaWYgKHVzZWRMbmc/LnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnICYmICghdGhpcy5vcHRpb25zLnByZWxvYWQgfHwgdGhpcy5vcHRpb25zLnByZWxvYWQubGVuZ3RoID09PSAwKSkgcmV0dXJuIHVzZWRDYWxsYmFjaygpO1xuICAgICAgY29uc3QgdG9Mb2FkID0gW107XG4gICAgICBjb25zdCBhcHBlbmQgPSBsbmcgPT4ge1xuICAgICAgICBpZiAoIWxuZykgcmV0dXJuO1xuICAgICAgICBpZiAobG5nID09PSAnY2ltb2RlJykgcmV0dXJuO1xuICAgICAgICBjb25zdCBsbmdzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsbmcpO1xuICAgICAgICBsbmdzLmZvckVhY2gobCA9PiB7XG4gICAgICAgICAgaWYgKGwgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgICAgaWYgKHRvTG9hZC5pbmRleE9mKGwpIDwgMCkgdG9Mb2FkLnB1c2gobCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICghdXNlZExuZykge1xuICAgICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgICBmYWxsYmFja3MuZm9yRWFjaChsID0+IGFwcGVuZChsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQodXNlZExuZyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMucHJlbG9hZD8uZm9yRWFjaD8uKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5sb2FkKHRvTG9hZCwgdGhpcy5vcHRpb25zLm5zLCBlID0+IHtcbiAgICAgICAgaWYgKCFlICYmICF0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgJiYgdGhpcy5sYW5ndWFnZSkgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICB1c2VkQ2FsbGJhY2soZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXNlZENhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxuICByZWxvYWRSZXNvdXJjZXMobG5ncywgbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGlmICh0eXBlb2YgbG5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBsbmdzO1xuICAgICAgbG5ncyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBucztcbiAgICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWxuZ3MpIGxuZ3MgPSB0aGlzLmxhbmd1YWdlcztcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5ucztcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnJlbG9hZChsbmdzLCBucywgZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIHVzZShtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYW4gdW5kZWZpbmVkIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAoIW1vZHVsZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhIHdyb25nIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdiYWNrZW5kJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmJhY2tlbmQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xvZ2dlcicgfHwgbW9kdWxlLmxvZyAmJiBtb2R1bGUud2FybiAmJiBtb2R1bGUuZXJyb3IpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sb2dnZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xhbmd1YWdlRGV0ZWN0b3InKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3RvciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnaTE4bkZvcm1hdCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5pMThuRm9ybWF0ID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdwb3N0UHJvY2Vzc29yJykge1xuICAgICAgcG9zdFByb2Nlc3Nvci5hZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSk7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2Zvcm1hdHRlcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJzNyZFBhcnR5Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLnB1c2gobW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UmVzb2x2ZWRMYW5ndWFnZShsKSB7XG4gICAgaWYgKCFsIHx8ICF0aGlzLmxhbmd1YWdlcykgcmV0dXJuO1xuICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGwpID4gLTEpIHJldHVybjtcbiAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgdGhpcy5sYW5ndWFnZXMubGVuZ3RoOyBsaSsrKSB7XG4gICAgICBjb25zdCBsbmdJbkxuZ3MgPSB0aGlzLmxhbmd1YWdlc1tsaV07XG4gICAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsbmdJbkxuZ3MpID4gLTEpIGNvbnRpbnVlO1xuICAgICAgaWYgKHRoaXMuc3RvcmUuaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zKGxuZ0luTG5ncykpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbG5nSW5MbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgJiYgdGhpcy5sYW5ndWFnZXMuaW5kZXhPZihsKSA8IDAgJiYgdGhpcy5zdG9yZS5oYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobCkpIHtcbiAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IGw7XG4gICAgICB0aGlzLmxhbmd1YWdlcy51bnNoaWZ0KGwpO1xuICAgIH1cbiAgfVxuICBjaGFuZ2VMYW5ndWFnZShsbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9IGxuZztcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdGhpcy5lbWl0KCdsYW5ndWFnZUNoYW5naW5nJywgbG5nKTtcbiAgICBjb25zdCBzZXRMbmdQcm9wcyA9IGwgPT4ge1xuICAgICAgdGhpcy5sYW5ndWFnZSA9IGw7XG4gICAgICB0aGlzLmxhbmd1YWdlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobCk7XG4gICAgICB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UobCk7XG4gICAgfTtcbiAgICBjb25zdCBkb25lID0gKGVyciwgbCkgPT4ge1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPT09IGxuZykge1xuICAgICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRvci5jaGFuZ2VMYW5ndWFnZShsKTtcbiAgICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdsYW5ndWFnZUNoYW5nZWQnLCBsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKC4uLmFyZ3MpID0+IHRoaXMudCguLi5hcmdzKSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgKC4uLmFyZ3MpID0+IHRoaXMudCguLi5hcmdzKSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRMbmcgPSBsbmdzID0+IHtcbiAgICAgIGlmICghbG5nICYmICFsbmdzICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvcikgbG5ncyA9IFtdO1xuICAgICAgY29uc3QgZmwgPSBpc1N0cmluZyhsbmdzKSA/IGxuZ3MgOiBsbmdzICYmIGxuZ3NbMF07XG4gICAgICBjb25zdCBsID0gdGhpcy5zdG9yZS5oYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMoZmwpID8gZmwgOiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGlzU3RyaW5nKGxuZ3MpID8gW2xuZ3NdIDogbG5ncyk7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAoIXRoaXMubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzZXRMbmdQcm9wcyhsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHJhbnNsYXRvci5sYW5ndWFnZSkgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3I/LmNhY2hlVXNlckxhbmd1YWdlPy4obCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRSZXNvdXJjZXMobCwgZXJyID0+IHtcbiAgICAgICAgZG9uZShlcnIsIGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgc2V0TG5nKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKSk7XG4gICAgfSBlbHNlIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkudGhlbihzZXRMbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdChzZXRMbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMbmcobG5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGdldEZpeGVkVChsbmcsIG5zLCBrZXlQcmVmaXgpIHtcbiAgICBjb25zdCBmaXhlZFQgPSAoa2V5LCBvcHRzLCAuLi5yZXN0KSA9PiB7XG4gICAgICBsZXQgbztcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbyA9IHRoaXMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihba2V5LCBvcHRzXS5jb25jYXQocmVzdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvLmxuZyA9IG8ubG5nIHx8IGZpeGVkVC5sbmc7XG4gICAgICBvLmxuZ3MgPSBvLmxuZ3MgfHwgZml4ZWRULmxuZ3M7XG4gICAgICBvLm5zID0gby5ucyB8fCBmaXhlZFQubnM7XG4gICAgICBpZiAoby5rZXlQcmVmaXggIT09ICcnKSBvLmtleVByZWZpeCA9IG8ua2V5UHJlZml4IHx8IGtleVByZWZpeCB8fCBmaXhlZFQua2V5UHJlZml4O1xuICAgICAgY29uc3Qga2V5U2VwYXJhdG9yID0gdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciB8fCAnLic7XG4gICAgICBsZXQgcmVzdWx0S2V5O1xuICAgICAgaWYgKG8ua2V5UHJlZml4ICYmIEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICByZXN1bHRLZXkgPSBrZXkubWFwKGsgPT4gYCR7by5rZXlQcmVmaXh9JHtrZXlTZXBhcmF0b3J9JHtrfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0S2V5ID0gby5rZXlQcmVmaXggPyBgJHtvLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2tleX1gIDoga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudChyZXN1bHRLZXksIG8pO1xuICAgIH07XG4gICAgaWYgKGlzU3RyaW5nKGxuZykpIHtcbiAgICAgIGZpeGVkVC5sbmcgPSBsbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpeGVkVC5sbmdzID0gbG5nO1xuICAgIH1cbiAgICBmaXhlZFQubnMgPSBucztcbiAgICBmaXhlZFQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHJldHVybiBmaXhlZFQ7XG4gIH1cbiAgdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvcj8udHJhbnNsYXRlKC4uLmFyZ3MpO1xuICB9XG4gIGV4aXN0cyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvcj8uZXhpc3RzKC4uLmFyZ3MpO1xuICB9XG4gIHNldERlZmF1bHROYW1lc3BhY2UobnMpIHtcbiAgICB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TID0gbnM7XG4gIH1cbiAgaGFzTG9hZGVkTmFtZXNwYWNlKG5zLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuZXh0IHdhcyBub3QgaW5pdGlhbGl6ZWQnLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5sYW5ndWFnZXMgfHwgIXRoaXMubGFuZ3VhZ2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuLmxhbmd1YWdlcyB3ZXJlIHVuZGVmaW5lZCBvciBlbXB0eScsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG5nID0gb3B0aW9ucy5sbmcgfHwgdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8IHRoaXMubGFuZ3VhZ2VzWzBdO1xuICAgIGNvbnN0IGZhbGxiYWNrTG5nID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIDogZmFsc2U7XG4gICAgY29uc3QgbGFzdExuZyA9IHRoaXMubGFuZ3VhZ2VzW3RoaXMubGFuZ3VhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGxvYWROb3RQZW5kaW5nID0gKGwsIG4pID0+IHtcbiAgICAgIGNvbnN0IGxvYWRTdGF0ZSA9IHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5zdGF0ZVtgJHtsfXwke259YF07XG4gICAgICByZXR1cm4gbG9hZFN0YXRlID09PSAtMSB8fCBsb2FkU3RhdGUgPT09IDAgfHwgbG9hZFN0YXRlID09PSAyO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMucHJlY2hlY2spIHtcbiAgICAgIGNvbnN0IHByZVJlc3VsdCA9IG9wdGlvbnMucHJlY2hlY2sodGhpcywgbG9hZE5vdFBlbmRpbmcpO1xuICAgICAgaWYgKHByZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcHJlUmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IuYmFja2VuZCB8fCB0aGlzLm9wdGlvbnMucmVzb3VyY2VzICYmICF0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChsb2FkTm90UGVuZGluZyhsbmcsIG5zKSAmJiAoIWZhbGxiYWNrTG5nIHx8IGxvYWROb3RQZW5kaW5nKGxhc3RMbmcsIG5zKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2FkTmFtZXNwYWNlcyhucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubnMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKG5zKSkgbnMgPSBbbnNdO1xuICAgIG5zLmZvckVhY2gobiA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5zLmluZGV4T2YobikgPCAwKSB0aGlzLm9wdGlvbnMubnMucHVzaChuKTtcbiAgICB9KTtcbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZExhbmd1YWdlcyhsbmdzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBpZiAoaXNTdHJpbmcobG5ncykpIGxuZ3MgPSBbbG5nc107XG4gICAgY29uc3QgcHJlbG9hZGVkID0gdGhpcy5vcHRpb25zLnByZWxvYWQgfHwgW107XG4gICAgY29uc3QgbmV3TG5ncyA9IGxuZ3MuZmlsdGVyKGxuZyA9PiBwcmVsb2FkZWQuaW5kZXhPZihsbmcpIDwgMCAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuaXNTdXBwb3J0ZWRDb2RlKGxuZykpO1xuICAgIGlmICghbmV3TG5ncy5sZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnByZWxvYWQgPSBwcmVsb2FkZWQuY29uY2F0KG5ld0xuZ3MpO1xuICAgIHRoaXMubG9hZFJlc291cmNlcyhlcnIgPT4ge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBkaXIobG5nKSB7XG4gICAgaWYgKCFsbmcpIGxuZyA9IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCAodGhpcy5sYW5ndWFnZXM/Lmxlbmd0aCA+IDAgPyB0aGlzLmxhbmd1YWdlc1swXSA6IHRoaXMubGFuZ3VhZ2UpO1xuICAgIGlmICghbG5nKSByZXR1cm4gJ3J0bCc7XG4gICAgaWYgKEludGwuTG9jYWxlKSB7XG4gICAgICBjb25zdCBsID0gbmV3IEludGwuTG9jYWxlKGxuZyk7XG4gICAgICBpZiAobCAmJiBsLmdldFRleHRJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRpID0gbC5nZXRUZXh0SW5mbygpO1xuICAgICAgICBpZiAodGkgJiYgdGkuZGlyZWN0aW9uKSByZXR1cm4gdGkuZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBydGxMbmdzID0gWydhcicsICdzaHUnLCAnc3FyJywgJ3NzaCcsICd4YWEnLCAneWhkJywgJ3l1ZCcsICdhYW8nLCAnYWJoJywgJ2FidicsICdhY20nLCAnYWNxJywgJ2FjdycsICdhY3gnLCAnYWN5JywgJ2FkZicsICdhZHMnLCAnYWViJywgJ2FlYycsICdhZmInLCAnYWpwJywgJ2FwYycsICdhcGQnLCAnYXJiJywgJ2FycScsICdhcnMnLCAnYXJ5JywgJ2FyeicsICdhdXonLCAnYXZsJywgJ2F5aCcsICdheWwnLCAnYXluJywgJ2F5cCcsICdiYnonLCAncGdhJywgJ2hlJywgJ2l3JywgJ3BzJywgJ3BidCcsICdwYnUnLCAncHN0JywgJ3BycCcsICdwcmQnLCAndWcnLCAndXInLCAneWRkJywgJ3lkcycsICd5aWgnLCAnamknLCAneWknLCAnaGJvJywgJ21lbicsICd4bW4nLCAnZmEnLCAnanByJywgJ3BlbycsICdwZXMnLCAncHJzJywgJ2R2JywgJ3NhbScsICdja2InXTtcbiAgICBjb25zdCBsYW5ndWFnZVV0aWxzID0gdGhpcy5zZXJ2aWNlcz8ubGFuZ3VhZ2VVdGlscyB8fCBuZXcgTGFuZ3VhZ2VVdGlsKGdldCgpKTtcbiAgICBpZiAobG5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignLWxhdG4nKSA+IDEpIHJldHVybiAnbHRyJztcbiAgICByZXR1cm4gcnRsTG5ncy5pbmRleE9mKGxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUobG5nKSkgPiAtMSB8fCBsbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCctYXJhYicpID4gMSA/ICdydGwnIDogJ2x0cic7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IEkxOG4ob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG4gIGNsb25lSW5zdGFuY2Uob3B0aW9ucyA9IHt9LCBjYWxsYmFjayA9IG5vb3ApIHtcbiAgICBjb25zdCBmb3JrUmVzb3VyY2VTdG9yZSA9IG9wdGlvbnMuZm9ya1Jlc291cmNlU3RvcmU7XG4gICAgaWYgKGZvcmtSZXNvdXJjZVN0b3JlKSBkZWxldGUgb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC4uLntcbiAgICAgICAgaXNDbG9uZTogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgSTE4bihtZXJnZWRPcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLmxvZ2dlciA9IGNsb25lLmxvZ2dlci5jbG9uZShvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgbWVtYmVyc1RvQ29weSA9IFsnc3RvcmUnLCAnc2VydmljZXMnLCAnbGFuZ3VhZ2UnXTtcbiAgICBtZW1iZXJzVG9Db3B5LmZvckVhY2gobSA9PiB7XG4gICAgICBjbG9uZVttXSA9IHRoaXNbbV07XG4gICAgfSk7XG4gICAgY2xvbmUuc2VydmljZXMgPSB7XG4gICAgICAuLi50aGlzLnNlcnZpY2VzXG4gICAgfTtcbiAgICBjbG9uZS5zZXJ2aWNlcy51dGlscyA9IHtcbiAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogY2xvbmUuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQoY2xvbmUpXG4gICAgfTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIHtcbiAgICAgIGNvbnN0IGNsb25lZERhdGEgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JlLmRhdGEpLnJlZHVjZSgocHJldiwgbCkgPT4ge1xuICAgICAgICBwcmV2W2xdID0ge1xuICAgICAgICAgIC4uLnRoaXMuc3RvcmUuZGF0YVtsXVxuICAgICAgICB9O1xuICAgICAgICBwcmV2W2xdID0gT2JqZWN0LmtleXMocHJldltsXSkucmVkdWNlKChhY2MsIG4pID0+IHtcbiAgICAgICAgICBhY2Nbbl0gPSB7XG4gICAgICAgICAgICAuLi5wcmV2W2xdW25dXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBwcmV2W2xdKTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9LCB7fSk7XG4gICAgICBjbG9uZS5zdG9yZSA9IG5ldyBSZXNvdXJjZVN0b3JlKGNsb25lZERhdGEsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgY2xvbmUuc2VydmljZXMucmVzb3VyY2VTdG9yZSA9IGNsb25lLnN0b3JlO1xuICAgIH1cbiAgICBjbG9uZS50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoY2xvbmUuc2VydmljZXMsIG1lcmdlZE9wdGlvbnMpO1xuICAgIGNsb25lLnRyYW5zbGF0b3Iub24oJyonLCAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgIGNsb25lLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0pO1xuICAgIGNsb25lLmluaXQobWVyZ2VkT3B0aW9ucywgY2FsbGJhY2spO1xuICAgIGNsb25lLnRyYW5zbGF0b3Iub3B0aW9ucyA9IG1lcmdlZE9wdGlvbnM7XG4gICAgY2xvbmUudHJhbnNsYXRvci5iYWNrZW5kQ29ubmVjdG9yLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICBsYW5ndWFnZXM6IHRoaXMubGFuZ3VhZ2VzLFxuICAgICAgcmVzb2x2ZWRMYW5ndWFnZTogdGhpcy5yZXNvbHZlZExhbmd1YWdlXG4gICAgfTtcbiAgfVxufVxuY29uc3QgaW5zdGFuY2UgPSBJMThuLmNyZWF0ZUluc3RhbmNlKCk7XG5pbnN0YW5jZS5jcmVhdGVJbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2U7XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlID0gaW5zdGFuY2UuY3JlYXRlSW5zdGFuY2U7XG5jb25zdCBkaXIgPSBpbnN0YW5jZS5kaXI7XG5jb25zdCBpbml0ID0gaW5zdGFuY2UuaW5pdDtcbmNvbnN0IGxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5sb2FkUmVzb3VyY2VzO1xuY29uc3QgcmVsb2FkUmVzb3VyY2VzID0gaW5zdGFuY2UucmVsb2FkUmVzb3VyY2VzO1xuY29uc3QgdXNlID0gaW5zdGFuY2UudXNlO1xuY29uc3QgY2hhbmdlTGFuZ3VhZ2UgPSBpbnN0YW5jZS5jaGFuZ2VMYW5ndWFnZTtcbmNvbnN0IGdldEZpeGVkVCA9IGluc3RhbmNlLmdldEZpeGVkVDtcbmNvbnN0IHQgPSBpbnN0YW5jZS50O1xuY29uc3QgZXhpc3RzID0gaW5zdGFuY2UuZXhpc3RzO1xuY29uc3Qgc2V0RGVmYXVsdE5hbWVzcGFjZSA9IGluc3RhbmNlLnNldERlZmF1bHROYW1lc3BhY2U7XG5jb25zdCBoYXNMb2FkZWROYW1lc3BhY2UgPSBpbnN0YW5jZS5oYXNMb2FkZWROYW1lc3BhY2U7XG5jb25zdCBsb2FkTmFtZXNwYWNlcyA9IGluc3RhbmNlLmxvYWROYW1lc3BhY2VzO1xuY29uc3QgbG9hZExhbmd1YWdlcyA9IGluc3RhbmNlLmxvYWRMYW5ndWFnZXM7XG5cbmV4cG9ydCB7IGNoYW5nZUxhbmd1YWdlLCBjcmVhdGVJbnN0YW5jZSwgaW5zdGFuY2UgYXMgZGVmYXVsdCwgZGlyLCBleGlzdHMsIGdldEZpeGVkVCwgaGFzTG9hZGVkTmFtZXNwYWNlLCBpbml0LCBsb2FkTGFuZ3VhZ2VzLCBsb2FkTmFtZXNwYWNlcywgbG9hZFJlc291cmNlcywgcmVsb2FkUmVzb3VyY2VzLCBzZXREZWZhdWx0TmFtZXNwYWNlLCB0LCB1c2UgfTtcbiJdLCJuYW1lcyI6WyJpc1N0cmluZyIsIm9iaiIsImRlZmVyIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFrZVN0cmluZyIsIm9iamVjdCIsImNvcHkiLCJhIiwicyIsInQiLCJmb3JFYWNoIiwibSIsImxhc3RPZlBhdGhTZXBhcmF0b3JSZWdFeHAiLCJjbGVhbktleSIsImtleSIsImluZGV4T2YiLCJyZXBsYWNlIiwiY2FuTm90VHJhdmVyc2VEZWVwZXIiLCJnZXRMYXN0T2ZQYXRoIiwicGF0aCIsIkVtcHR5Iiwic3RhY2siLCJzcGxpdCIsInN0YWNrSW5kZXgiLCJsZW5ndGgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrIiwic2V0UGF0aCIsIm5ld1ZhbHVlIiwidW5kZWZpbmVkIiwiZSIsInAiLCJzbGljZSIsImxhc3QiLCJwdXNoUGF0aCIsImNvbmNhdCIsInB1c2giLCJnZXRQYXRoIiwiZ2V0UGF0aFdpdGhEZWZhdWx0cyIsImRhdGEiLCJkZWZhdWx0RGF0YSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsIm92ZXJ3cml0ZSIsInByb3AiLCJTdHJpbmciLCJyZWdleEVzY2FwZSIsInN0ciIsIl9lbnRpdHlNYXAiLCJlc2NhcGUiLCJSZWdFeHBDYWNoZSIsImNvbnN0cnVjdG9yIiwiY2FwYWNpdHkiLCJyZWdFeHBNYXAiLCJNYXAiLCJyZWdFeHBRdWV1ZSIsImdldFJlZ0V4cCIsInBhdHRlcm4iLCJyZWdFeHBGcm9tQ2FjaGUiLCJnZXQiLCJyZWdFeHBOZXciLCJSZWdFeHAiLCJkZWxldGUiLCJzaGlmdCIsInNldCIsImNoYXJzIiwibG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlIiwibG9va3NMaWtlT2JqZWN0UGF0aCIsIm5zU2VwYXJhdG9yIiwia2V5U2VwYXJhdG9yIiwicG9zc2libGVDaGFycyIsImZpbHRlciIsImMiLCJyIiwibWFwIiwiam9pbiIsIm1hdGNoZWQiLCJ0ZXN0Iiwia2kiLCJzdWJzdHJpbmciLCJkZWVwRmluZCIsInRva2VucyIsImN1cnJlbnQiLCJpIiwibmV4dCIsIm5leHRQYXRoIiwiaiIsImdldENsZWFuZWRDb2RlIiwiY29kZSIsImNvbnNvbGVMb2dnZXIiLCJ0eXBlIiwibG9nIiwiYXJncyIsIm91dHB1dCIsIndhcm4iLCJlcnJvciIsImNvbnNvbGUiLCJhcHBseSIsIkxvZ2dlciIsImNvbmNyZXRlTG9nZ2VyIiwib3B0aW9ucyIsImluaXQiLCJwcmVmaXgiLCJsb2dnZXIiLCJkZWJ1ZyIsImZvcndhcmQiLCJkZXByZWNhdGUiLCJsdmwiLCJkZWJ1Z09ubHkiLCJjcmVhdGUiLCJtb2R1bGVOYW1lIiwiY2xvbmUiLCJiYXNlTG9nZ2VyIiwiRXZlbnRFbWl0dGVyIiwib2JzZXJ2ZXJzIiwib24iLCJldmVudHMiLCJsaXN0ZW5lciIsImV2ZW50IiwibnVtTGlzdGVuZXJzIiwib2ZmIiwiZW1pdCIsImNsb25lZCIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJvYnNlcnZlciIsIm51bVRpbWVzQWRkZWQiLCJSZXNvdXJjZVN0b3JlIiwibnMiLCJkZWZhdWx0TlMiLCJpZ25vcmVKU09OU3RydWN0dXJlIiwiYWRkTmFtZXNwYWNlcyIsInJlbW92ZU5hbWVzcGFjZXMiLCJpbmRleCIsInNwbGljZSIsImdldFJlc291cmNlIiwibG5nIiwiaXNBcnJheSIsInJlc3VsdCIsImFkZFJlc291cmNlIiwic2lsZW50IiwiYWRkUmVzb3VyY2VzIiwicmVzb3VyY2VzIiwiYWRkUmVzb3VyY2VCdW5kbGUiLCJkZWVwIiwic2tpcENvcHkiLCJwYWNrIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicmVtb3ZlUmVzb3VyY2VCdW5kbGUiLCJoYXNSZXNvdXJjZUJ1bmRsZSIsImdldFJlc291cmNlQnVuZGxlIiwiZ2V0RGF0YUJ5TGFuZ3VhZ2UiLCJoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMiLCJuIiwia2V5cyIsImZpbmQiLCJ2IiwidG9KU09OIiwicG9zdFByb2Nlc3NvciIsInByb2Nlc3NvcnMiLCJhZGRQb3N0UHJvY2Vzc29yIiwibW9kdWxlIiwibmFtZSIsImhhbmRsZSIsInRyYW5zbGF0b3IiLCJwcm9jZXNzb3IiLCJwcm9jZXNzIiwiY2hlY2tlZExvYWRlZEZvciIsInNob3VsZEhhbmRsZUFzT2JqZWN0IiwiVHJhbnNsYXRvciIsInNlcnZpY2VzIiwiY2hhbmdlTGFuZ3VhZ2UiLCJsYW5ndWFnZSIsImV4aXN0cyIsIm8iLCJpbnRlcnBvbGF0aW9uIiwib3B0IiwicmVzb2x2ZWQiLCJleHRyYWN0RnJvbUtleSIsIm5hbWVzcGFjZXMiLCJ3b3VsZENoZWNrRm9yTnNJbktleSIsInNlZW1zTmF0dXJhbExhbmd1YWdlIiwidXNlckRlZmluZWRLZXlTZXBhcmF0b3IiLCJ1c2VyRGVmaW5lZE5zU2VwYXJhdG9yIiwibWF0Y2giLCJpbnRlcnBvbGF0b3IiLCJuZXN0aW5nUmVnZXhwIiwicGFydHMiLCJ0cmFuc2xhdGUiLCJsYXN0S2V5Iiwib3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIiLCJhcmd1bWVudHMiLCJyZXR1cm5EZXRhaWxzIiwibmFtZXNwYWNlIiwiYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUiLCJ0b0xvd2VyQ2FzZSIsInVzZWRLZXkiLCJleGFjdFVzZWRLZXkiLCJ1c2VkTG5nIiwidXNlZE5TIiwidXNlZFBhcmFtcyIsImdldFVzZWRQYXJhbXNEZXRhaWxzIiwicmVzVXNlZEtleSIsInJlc0V4YWN0VXNlZEtleSIsIm5vT2JqZWN0Iiwiam9pbkFycmF5cyIsImhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0IiwiaTE4bkZvcm1hdCIsImhhbmRsZUFzT2JqZWN0IiwibmVlZHNQbHVyYWxIYW5kbGluZyIsImNvdW50IiwiaGFzRGVmYXVsdFZhbHVlIiwiZGVmYXVsdFZhbHVlU3VmZml4IiwicGx1cmFsUmVzb2x2ZXIiLCJnZXRTdWZmaXgiLCJkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2siLCJvcmRpbmFsIiwibmVlZHNaZXJvU3VmZml4TG9va3VwIiwiZGVmYXVsdFZhbHVlIiwicGx1cmFsU2VwYXJhdG9yIiwicmVzRm9yT2JqSG5kbCIsInJlc1R5cGUiLCJ0b1N0cmluZyIsInJldHVybk9iamVjdHMiLCJyZXR1cm5lZE9iamVjdEhhbmRsZXIiLCJyZXNUeXBlSXNBcnJheSIsIm5ld0tleVRvVXNlIiwiZGVlcEtleSIsImV4dGVuZFRyYW5zbGF0aW9uIiwidXNlZERlZmF1bHQiLCJpc1ZhbGlkTG9va3VwIiwibWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5IiwicmVzRm9yTWlzc2luZyIsInVwZGF0ZU1pc3NpbmciLCJmayIsImxuZ3MiLCJmYWxsYmFja0xuZ3MiLCJsYW5ndWFnZVV0aWxzIiwiZ2V0RmFsbGJhY2tDb2RlcyIsImZhbGxiYWNrTG5nIiwic2F2ZU1pc3NpbmdUbyIsInRvUmVzb2x2ZUhpZXJhcmNoeSIsInNlbmQiLCJsIiwic3BlY2lmaWNEZWZhdWx0VmFsdWUiLCJkZWZhdWx0Rm9yTWlzc2luZyIsIm1pc3NpbmdLZXlIYW5kbGVyIiwiYmFja2VuZENvbm5lY3RvciIsInNhdmVNaXNzaW5nIiwic2F2ZU1pc3NpbmdQbHVyYWxzIiwic3VmZml4ZXMiLCJnZXRTdWZmaXhlcyIsInN1ZmZpeCIsImFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSIsInBhcnNlTWlzc2luZ0tleUhhbmRsZXIiLCJkZWZhdWx0VmFyaWFibGVzIiwic2tpcEludGVycG9sYXRpb24iLCJza2lwT25WYXJpYWJsZXMiLCJuZXN0QmVmIiwibmIiLCJpbnRlcnBvbGF0ZSIsIm5hIiwibmVzdEFmdCIsIm5lc3QiLCJjb250ZXh0IiwicmVzZXQiLCJwb3N0UHJvY2VzcyIsInBvc3RQcm9jZXNzb3JOYW1lcyIsImFwcGx5UG9zdFByb2Nlc3NvciIsInBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkIiwiaTE4blJlc29sdmVkIiwiZm91bmQiLCJleHRyYWN0ZWQiLCJmYWxsYmFja05TIiwibmVlZHNDb250ZXh0SGFuZGxpbmciLCJjb2RlcyIsInV0aWxzIiwiaGFzTG9hZGVkTmFtZXNwYWNlIiwiZmluYWxLZXlzIiwiYWRkTG9va3VwS2V5cyIsInBsdXJhbFN1ZmZpeCIsInplcm9TdWZmaXgiLCJvcmRpbmFsUHJlZml4IiwiY29udGV4dEtleSIsImNvbnRleHRTZXBhcmF0b3IiLCJwb3NzaWJsZUtleSIsInBvcCIsInJldHVybk51bGwiLCJyZXR1cm5FbXB0eVN0cmluZyIsInJlc291cmNlU3RvcmUiLCJvcHRpb25zS2V5cyIsInVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSIsIm9wdGlvbiIsIkxhbmd1YWdlVXRpbCIsInN1cHBvcnRlZExuZ3MiLCJnZXRTY3JpcHRQYXJ0RnJvbUNvZGUiLCJmb3JtYXRMYW5ndWFnZUNvZGUiLCJnZXRMYW5ndWFnZVBhcnRGcm9tQ29kZSIsImZvcm1hdHRlZENvZGUiLCJJbnRsIiwiZ2V0Q2Fub25pY2FsTG9jYWxlcyIsImxvd2VyQ2FzZUxuZyIsImNsZWFuQ29kZSIsImlzU3VwcG9ydGVkQ29kZSIsImxvYWQiLCJub25FeHBsaWNpdFN1cHBvcnRlZExuZ3MiLCJnZXRCZXN0TWF0Y2hGcm9tQ29kZXMiLCJjbGVhbmVkTG5nIiwibG5nU2NPbmx5IiwibG5nT25seSIsInN1cHBvcnRlZExuZyIsImZhbGxiYWNrcyIsImRlZmF1bHQiLCJmYWxsYmFja0NvZGUiLCJmYWxsYmFja0NvZGVzIiwiYWRkQ29kZSIsImZjIiwic3VmZml4ZXNPcmRlciIsInplcm8iLCJvbmUiLCJ0d28iLCJmZXciLCJtYW55Iiwib3RoZXIiLCJkdW1teVJ1bGUiLCJzZWxlY3QiLCJyZXNvbHZlZE9wdGlvbnMiLCJwbHVyYWxDYXRlZ29yaWVzIiwiUGx1cmFsUmVzb2x2ZXIiLCJwbHVyYWxSdWxlc0NhY2hlIiwiYWRkUnVsZSIsInJ1bGVzIiwiY2xlYXJDYWNoZSIsImdldFJ1bGUiLCJjbGVhbmVkQ29kZSIsImNhY2hlS2V5IiwicnVsZSIsIlBsdXJhbFJ1bGVzIiwiZXJyIiwibG5nUGFydCIsIm5lZWRzUGx1cmFsIiwiZ2V0UGx1cmFsRm9ybXNPZktleSIsInNvcnQiLCJwbHVyYWxDYXRlZ29yeTEiLCJwbHVyYWxDYXRlZ29yeTIiLCJwbHVyYWxDYXRlZ29yeSIsInByZXBlbmQiLCJkZWVwRmluZFdpdGhEZWZhdWx0cyIsInJlZ2V4U2FmZSIsInZhbCIsIkludGVycG9sYXRvciIsImZvcm1hdCIsImVzY2FwZVZhbHVlIiwiZXNjYXBlJDEiLCJ1c2VSYXdWYWx1ZVRvRXNjYXBlIiwicHJlZml4RXNjYXBlZCIsInN1ZmZpeEVzY2FwZWQiLCJmb3JtYXRTZXBhcmF0b3IiLCJ1bmVzY2FwZVN1ZmZpeCIsInVuZXNjYXBlUHJlZml4IiwibmVzdGluZ1ByZWZpeCIsIm5lc3RpbmdQcmVmaXhFc2NhcGVkIiwibmVzdGluZ1N1ZmZpeCIsIm5lc3RpbmdTdWZmaXhFc2NhcGVkIiwibmVzdGluZ09wdGlvbnNTZXBhcmF0b3IiLCJtYXhSZXBsYWNlcyIsImFsd2F5c0Zvcm1hdCIsInJlc2V0UmVnRXhwIiwiZ2V0T3JSZXNldFJlZ0V4cCIsImV4aXN0aW5nUmVnRXhwIiwibGFzdEluZGV4IiwicmVnZXhwIiwicmVnZXhwVW5lc2NhcGUiLCJyZXBsYWNlcyIsImhhbmRsZUZvcm1hdCIsImludGVycG9sYXRpb25rZXkiLCJ0cmltIiwiZiIsIm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciIsInRvZG9zIiwicmVnZXgiLCJzYWZlVmFsdWUiLCJ0b2RvIiwiZXhlYyIsIm1hdGNoZWRWYXIiLCJ0ZW1wIiwiY2xvbmVkT3B0aW9ucyIsImhhbmRsZUhhc09wdGlvbnMiLCJpbmhlcml0ZWRPcHRpb25zIiwic2VwIiwib3B0aW9uc1N0cmluZyIsIm1hdGNoZWRTaW5nbGVRdW90ZXMiLCJtYXRjaGVkRG91YmxlUXVvdGVzIiwiZm9ybWF0dGVycyIsImtleUVuZEluZGV4IiwibGFzdEluZGV4T2YiLCJlbGVtIiwiQm9vbGVhbiIsInJlZHVjZSIsInBhcnNlRm9ybWF0U3RyIiwiZm9ybWF0U3RyIiwiZm9ybWF0TmFtZSIsImZvcm1hdE9wdGlvbnMiLCJvcHRTdHIiLCJjdXJyZW5jeSIsInJhbmdlIiwib3B0cyIsInJlc3QiLCJ0cmltbWVkS2V5IiwiaXNOYU4iLCJwYXJzZUludCIsImNyZWF0ZUNhY2hlZEZvcm1hdHRlciIsImZuIiwiY2FjaGUiLCJvcHRGb3JDYWNoZSIsImZvcm1hdFBhcmFtcyIsImZybSIsImNyZWF0ZU5vbkNhY2hlZEZvcm1hdHRlciIsIkZvcm1hdHRlciIsImNmIiwiY2FjaGVJbkJ1aWx0Rm9ybWF0cyIsImZvcm1hdHMiLCJudW1iZXIiLCJmb3JtYXR0ZXIiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsImRhdGV0aW1lIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZWxhdGl2ZXRpbWUiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJsaXN0IiwiTGlzdEZvcm1hdCIsImFkZCIsImFkZENhY2hlZCIsImZpbmRJbmRleCIsIm1lbSIsImZvcm1hdHRlZCIsInZhbE9wdGlvbnMiLCJsb2NhbGUiLCJyZW1vdmVQZW5kaW5nIiwicSIsInBlbmRpbmciLCJwZW5kaW5nQ291bnQiLCJDb25uZWN0b3IiLCJiYWNrZW5kIiwic3RvcmUiLCJ3YWl0aW5nUmVhZHMiLCJtYXhQYXJhbGxlbFJlYWRzIiwicmVhZGluZ0NhbGxzIiwibWF4UmV0cmllcyIsInJldHJ5VGltZW91dCIsInN0YXRlIiwicXVldWUiLCJxdWV1ZUxvYWQiLCJsYW5ndWFnZXMiLCJjYWxsYmFjayIsInRvTG9hZCIsInRvTG9hZExhbmd1YWdlcyIsInRvTG9hZE5hbWVzcGFjZXMiLCJoYXNBbGxOYW1lc3BhY2VzIiwicmVsb2FkIiwibG9hZGVkIiwiZXJyb3JzIiwiZG9uZSIsImxvYWRlZEtleXMiLCJyZWFkIiwiZmNOYW1lIiwidHJpZWQiLCJ3YWl0IiwicmVzb2x2ZXIiLCJzZXRUaW1lb3V0IiwiYmluZCIsInRoZW4iLCJjYXRjaCIsInByZXBhcmVMb2FkaW5nIiwibG9hZE9uZSIsImZhbGxiYWNrVmFsdWUiLCJpc1VwZGF0ZSIsImNsYiIsImluaXRBc3luYyIsInByZWxvYWQiLCJzaW1wbGlmeVBsdXJhbFN1ZmZpeCIsInBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzIiwicmV0IiwidERlc2NyaXB0aW9uIiwidHJhbnNmb3JtT3B0aW9ucyIsImluaXRJbW1lZGlhdGUiLCJub29wIiwiYmluZE1lbWJlckZ1bmN0aW9ucyIsImluc3QiLCJtZW1zIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFByb3RvdHlwZU9mIiwiSTE4biIsIm1vZHVsZXMiLCJleHRlcm5hbCIsImlzSW5pdGlhbGl6ZWQiLCJpc0Nsb25lIiwiaXNJbml0aWFsaXppbmciLCJkZWZPcHRzIiwiY3JlYXRlQ2xhc3NPbkRlbWFuZCIsIkNsYXNzT3JPYmplY3QiLCJsdSIsInVzaW5nTGVnYWN5Rm9ybWF0RnVuY3Rpb24iLCJsYW5ndWFnZURldGVjdG9yIiwiZGV0ZWN0aW9uIiwic3RvcmVBcGkiLCJzdG9yZUFwaUNoYWluZWQiLCJkZWZlcnJlZCIsImZpbmlzaCIsImluaXRpYWxpemVkU3RvcmVPbmNlIiwibG9hZFJlc291cmNlcyIsInVzZWRDYWxsYmFjayIsImFwcGVuZCIsInJlc29sdmVkTGFuZ3VhZ2UiLCJzZXRSZXNvbHZlZExhbmd1YWdlIiwicmVsb2FkUmVzb3VyY2VzIiwidXNlIiwiRXJyb3IiLCJsaSIsImxuZ0luTG5ncyIsInVuc2hpZnQiLCJpc0xhbmd1YWdlQ2hhbmdpbmdUbyIsInNldExuZ1Byb3BzIiwic2V0TG5nIiwiZmwiLCJjYWNoZVVzZXJMYW5ndWFnZSIsImFzeW5jIiwiZGV0ZWN0IiwiZ2V0Rml4ZWRUIiwia2V5UHJlZml4IiwiZml4ZWRUIiwicmVzdWx0S2V5Iiwic2V0RGVmYXVsdE5hbWVzcGFjZSIsImxhc3RMbmciLCJsb2FkTm90UGVuZGluZyIsImxvYWRTdGF0ZSIsInByZWNoZWNrIiwicHJlUmVzdWx0IiwibG9hZE5hbWVzcGFjZXMiLCJsb2FkTGFuZ3VhZ2VzIiwicHJlbG9hZGVkIiwibmV3TG5ncyIsImRpciIsIkxvY2FsZSIsImdldFRleHRJbmZvIiwidGkiLCJkaXJlY3Rpb24iLCJydGxMbmdzIiwiY3JlYXRlSW5zdGFuY2UiLCJjbG9uZUluc3RhbmNlIiwiZm9ya1Jlc291cmNlU3RvcmUiLCJtZXJnZWRPcHRpb25zIiwibWVtYmVyc1RvQ29weSIsImNsb25lZERhdGEiLCJwcmV2IiwiYWNjIiwiaW5zdGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;