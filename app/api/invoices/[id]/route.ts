import { NextResponse } from 'next/server'
import { supabase } from '@/lib/supabase'

// GET a specific invoice by ID
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const id = params.id
    
    const { data, error } = await supabase
      .from('invoices')
      .select(`
        *,
        order:orders(
          *,
          customer:customers(*),
          order_items:order_items(
            *,
            product:products(*)
          )
        ),
        accounting_entries:accounting_entries(*)
      `)
      .eq('id', id)
      .single()
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    if (!data) {
      return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })
    }
    
    return NextResponse.json({ invoice: data })
  } catch (error) {
    console.error('Error fetching invoice:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// PUT update an invoice
export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const id = params.id
    const body = await request.json()
    const { status, payment_date, payment_method, notes } = body
    
    // Check if we're marking the invoice as paid, which will trigger accounting entry generation
    const isPaid = status === 'paid'
    
    // First, check if the invoice exists and get its current status
    const { data: existingInvoice, error: fetchError } = await supabase
      .from('invoices')
      .select('status, accounting_entries:accounting_entries(id)')
      .eq('id', id)
      .single()
    
    if (fetchError || !existingInvoice) {
      return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })
    }
    
    // If we're marking as paid an already paid invoice, prevent duplicate accounting entries
    if (isPaid && existingInvoice.status === 'paid' && existingInvoice.accounting_entries?.length > 0) {
      return NextResponse.json({ 
        error: 'Invoice is already paid and accounting entries have been generated' 
      }, { status: 400 })
    }
    
    // Update the invoice
    const updateData: any = { status, notes }
    
    // Only include payment details if we're marking as paid
    if (isPaid) {
      updateData.payment_date = payment_date || new Date().toISOString()
      updateData.payment_method = payment_method || 'bank_transfer'
    }
    
    const { data, error } = await supabase
      .from('invoices')
      .update(updateData)
      .eq('id', id)
      .select()
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    if (data.length === 0) {
      return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })
    }
    
    // If the invoice was marked as paid, accounting entries will be automatically generated by the database trigger
    // Let's fetch the complete invoice with the newly generated accounting entries
    let completeInvoice = data[0]
    
    if (isPaid) {
      const { data: invoiceWithAccounting, error: accountingError } = await supabase
        .from('invoices')
        .select(`
          *,
          order:orders(
            *,
            customer:customers(*),
            order_items:order_items(
              *,
              product:products(*)
            )
          ),
          accounting_entries:accounting_entries(*)
        `)
        .eq('id', id)
        .single()
      
      if (!accountingError && invoiceWithAccounting) {
        completeInvoice = invoiceWithAccounting
      }
    }
    
    return NextResponse.json({ 
      invoice: completeInvoice,
      message: isPaid ? '請求書が支払済みとしてマークされ、会計エントリが自動生成されました' : '請求書が更新されました'
    })
  } catch (error) {
    console.error('Error updating invoice:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// DELETE an invoice (only allowed for draft invoices)
export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const id = params.id
    
    // Check if the invoice has accounting entries
    const { data: invoiceData, error: fetchError } = await supabase
      .from('invoices')
      .select('status, accounting_entries:accounting_entries(id)')
      .eq('id', id)
      .single()
    
    if (fetchError) {
      return NextResponse.json({ error: fetchError.message }, { status: 500 })
    }
    
    // Prevent deletion of paid invoices with accounting entries
    if (invoiceData?.status === 'paid' && invoiceData?.accounting_entries?.length > 0) {
      return NextResponse.json({ 
        error: 'Cannot delete a paid invoice with accounting entries.' 
      }, { status: 400 })
    }
    
    // Delete any accounting entries first (should be none if we get here)
    const { error: entriesError } = await supabase
      .from('accounting_entries')
      .delete()
      .eq('invoice_id', id)
    
    if (entriesError) {
      return NextResponse.json({ error: entriesError.message }, { status: 500 })
    }
    
    // Then delete the invoice
    const { error } = await supabase
      .from('invoices')
      .delete()
      .eq('id', id)
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json({ success: true, message: '請求書が削除されました' })
  } catch (error) {
    console.error('Error deleting invoice:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
